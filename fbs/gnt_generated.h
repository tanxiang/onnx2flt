// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GNT_NN_H_
#define FLATBUFFERS_GENERATED_GNT_NN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 22 &&
              FLATBUFFERS_VERSION_MINOR == 10 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace nn {

struct versionInfo;

struct TensorInfo;
struct TensorInfoBuilder;

struct rawTensor;
struct rawTensorBuilder;

struct i8Tensor;
struct i8TensorBuilder;

struct i16Tensor;
struct i16TensorBuilder;

struct i32Tensor;
struct i32TensorBuilder;

struct i64Tensor;
struct i64TensorBuilder;

struct f16Tensor;
struct f16TensorBuilder;

struct f32Tensor;
struct f32TensorBuilder;

struct f64Tensor;
struct f64TensorBuilder;

struct QuantInfo;
struct QuantInfoBuilder;

struct InputTensor;
struct InputTensorBuilder;

struct LinkOd;
struct LinkOdBuilder;

struct Link;
struct LinkBuilder;

struct Pads;

struct Stride;

struct Dilation;

struct KernelShape;

struct Group;

struct CONV_2D;
struct CONV_2DBuilder;

struct AVERAGE_POOL_2D;
struct AVERAGE_POOL_2DBuilder;

struct MAX_POOL_2D;
struct MAX_POOL_2DBuilder;

struct RELU;
struct RELUBuilder;

struct SOFTMAX;
struct SOFTMAXBuilder;

struct FULLY_CONNECTED;
struct FULLY_CONNECTEDBuilder;

struct ADD;
struct ADDBuilder;

struct SUB;
struct SUBBuilder;

struct MUL;
struct MULBuilder;

struct CONCATENATION;
struct CONCATENATIONBuilder;

struct DEPTHWISE_CONV_2D;
struct DEPTHWISE_CONV_2DBuilder;

struct BATCH_TO_SPACE_ND;
struct BATCH_TO_SPACE_NDBuilder;

struct SPACE_TO_BATCH_ND;
struct SPACE_TO_BATCH_NDBuilder;

struct STRIDED_SLICE;
struct STRIDED_SLICEBuilder;

struct DEQUANTIZE;
struct DEQUANTIZEBuilder;

struct LOCAL_RESPONSE_NORMALIZATION;
struct LOCAL_RESPONSE_NORMALIZATIONBuilder;

struct TANH;
struct TANHBuilder;

struct FLOOR;
struct FLOORBuilder;

struct LOGISTIC;
struct LOGISTICBuilder;

struct PRELU;
struct PRELUBuilder;

struct POW;
struct POWBuilder;

struct NEG;
struct NEGBuilder;

struct MINIMUM;
struct MINIMUMBuilder;

struct MAXIMUM;
struct MAXIMUMBuilder;

struct LOG;
struct LOGBuilder;

struct ABS;
struct ABSBuilder;

struct EXP;
struct EXPBuilder;

struct GATHER;
struct GATHERBuilder;

struct RESHAPE;
struct RESHAPEBuilder;

struct Configure;
struct ConfigureBuilder;

struct Graph;
struct GraphBuilder;

enum class DataType : int8_t {
  Float = 0,
  Int = 1,
  QuantAsymm = 2,
  QuantSymm = 3,
  QuantSymmPerChannel = 4,
  MIN = Float,
  MAX = QuantSymmPerChannel
};

inline const DataType (&EnumValuesDataType())[5] {
  static const DataType values[] = {
    DataType::Float,
    DataType::Int,
    DataType::QuantAsymm,
    DataType::QuantSymm,
    DataType::QuantSymmPerChannel
  };
  return values;
}

inline const char * const *EnumNamesDataType() {
  static const char * const names[6] = {
    "Float",
    "Int",
    "QuantAsymm",
    "QuantSymm",
    "QuantSymmPerChannel",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataType(DataType e) {
  if (flatbuffers::IsOutRange(e, DataType::Float, DataType::QuantSymmPerChannel)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataType()[index];
}

enum class FuseCode : int8_t {
  Relu = 0,
  Relu1 = 1,
  Relu6 = 2,
  MIN = Relu,
  MAX = Relu6
};

inline const FuseCode (&EnumValuesFuseCode())[3] {
  static const FuseCode values[] = {
    FuseCode::Relu,
    FuseCode::Relu1,
    FuseCode::Relu6
  };
  return values;
}

inline const char * const *EnumNamesFuseCode() {
  static const char * const names[4] = {
    "Relu",
    "Relu1",
    "Relu6",
    nullptr
  };
  return names;
}

inline const char *EnumNameFuseCode(FuseCode e) {
  if (flatbuffers::IsOutRange(e, FuseCode::Relu, FuseCode::Relu6)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFuseCode()[index];
}

enum class Layer : uint8_t {
  NONE = 0,
  InputTensor = 1,
  rawTensor = 2,
  i8Tensor = 3,
  i16Tensor = 4,
  i32Tensor = 5,
  i64Tensor = 6,
  f16Tensor = 7,
  f32Tensor = 8,
  f64Tensor = 9,
  CONV_2D = 10,
  AVERAGE_POOL_2D = 11,
  MAX_POOL_2D = 12,
  RELU = 13,
  SOFTMAX = 14,
  FULLY_CONNECTED = 15,
  ADD = 16,
  CONCATENATION = 17,
  DEPTHWISE_CONV_2D = 18,
  BATCH_TO_SPACE_ND = 19,
  SPACE_TO_BATCH_ND = 20,
  STRIDED_SLICE = 21,
  MUL = 22,
  DEQUANTIZE = 23,
  LOCAL_RESPONSE_NORMALIZATION = 24,
  TANH = 25,
  FLOOR = 26,
  LOGISTIC = 27,
  PRELU = 28,
  POW = 29,
  NEG = 30,
  MINIMUM = 31,
  MAXIMUM = 32,
  LOG = 33,
  ABS = 34,
  EXP = 35,
  SUB = 36,
  GATHER = 37,
  RESHAPE = 38,
  Configure = 39,
  MIN = NONE,
  MAX = Configure
};

inline const Layer (&EnumValuesLayer())[40] {
  static const Layer values[] = {
    Layer::NONE,
    Layer::InputTensor,
    Layer::rawTensor,
    Layer::i8Tensor,
    Layer::i16Tensor,
    Layer::i32Tensor,
    Layer::i64Tensor,
    Layer::f16Tensor,
    Layer::f32Tensor,
    Layer::f64Tensor,
    Layer::CONV_2D,
    Layer::AVERAGE_POOL_2D,
    Layer::MAX_POOL_2D,
    Layer::RELU,
    Layer::SOFTMAX,
    Layer::FULLY_CONNECTED,
    Layer::ADD,
    Layer::CONCATENATION,
    Layer::DEPTHWISE_CONV_2D,
    Layer::BATCH_TO_SPACE_ND,
    Layer::SPACE_TO_BATCH_ND,
    Layer::STRIDED_SLICE,
    Layer::MUL,
    Layer::DEQUANTIZE,
    Layer::LOCAL_RESPONSE_NORMALIZATION,
    Layer::TANH,
    Layer::FLOOR,
    Layer::LOGISTIC,
    Layer::PRELU,
    Layer::POW,
    Layer::NEG,
    Layer::MINIMUM,
    Layer::MAXIMUM,
    Layer::LOG,
    Layer::ABS,
    Layer::EXP,
    Layer::SUB,
    Layer::GATHER,
    Layer::RESHAPE,
    Layer::Configure
  };
  return values;
}

inline const char * const *EnumNamesLayer() {
  static const char * const names[41] = {
    "NONE",
    "InputTensor",
    "rawTensor",
    "i8Tensor",
    "i16Tensor",
    "i32Tensor",
    "i64Tensor",
    "f16Tensor",
    "f32Tensor",
    "f64Tensor",
    "CONV_2D",
    "AVERAGE_POOL_2D",
    "MAX_POOL_2D",
    "RELU",
    "SOFTMAX",
    "FULLY_CONNECTED",
    "ADD",
    "CONCATENATION",
    "DEPTHWISE_CONV_2D",
    "BATCH_TO_SPACE_ND",
    "SPACE_TO_BATCH_ND",
    "STRIDED_SLICE",
    "MUL",
    "DEQUANTIZE",
    "LOCAL_RESPONSE_NORMALIZATION",
    "TANH",
    "FLOOR",
    "LOGISTIC",
    "PRELU",
    "POW",
    "NEG",
    "MINIMUM",
    "MAXIMUM",
    "LOG",
    "ABS",
    "EXP",
    "SUB",
    "GATHER",
    "RESHAPE",
    "Configure",
    nullptr
  };
  return names;
}

inline const char *EnumNameLayer(Layer e) {
  if (flatbuffers::IsOutRange(e, Layer::NONE, Layer::Configure)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLayer()[index];
}

template<typename T> struct LayerTraits {
  static const Layer enum_value = Layer::NONE;
};

template<> struct LayerTraits<nn::InputTensor> {
  static const Layer enum_value = Layer::InputTensor;
};

template<> struct LayerTraits<nn::rawTensor> {
  static const Layer enum_value = Layer::rawTensor;
};

template<> struct LayerTraits<nn::i8Tensor> {
  static const Layer enum_value = Layer::i8Tensor;
};

template<> struct LayerTraits<nn::i16Tensor> {
  static const Layer enum_value = Layer::i16Tensor;
};

template<> struct LayerTraits<nn::i32Tensor> {
  static const Layer enum_value = Layer::i32Tensor;
};

template<> struct LayerTraits<nn::i64Tensor> {
  static const Layer enum_value = Layer::i64Tensor;
};

template<> struct LayerTraits<nn::f16Tensor> {
  static const Layer enum_value = Layer::f16Tensor;
};

template<> struct LayerTraits<nn::f32Tensor> {
  static const Layer enum_value = Layer::f32Tensor;
};

template<> struct LayerTraits<nn::f64Tensor> {
  static const Layer enum_value = Layer::f64Tensor;
};

template<> struct LayerTraits<nn::CONV_2D> {
  static const Layer enum_value = Layer::CONV_2D;
};

template<> struct LayerTraits<nn::AVERAGE_POOL_2D> {
  static const Layer enum_value = Layer::AVERAGE_POOL_2D;
};

template<> struct LayerTraits<nn::MAX_POOL_2D> {
  static const Layer enum_value = Layer::MAX_POOL_2D;
};

template<> struct LayerTraits<nn::RELU> {
  static const Layer enum_value = Layer::RELU;
};

template<> struct LayerTraits<nn::SOFTMAX> {
  static const Layer enum_value = Layer::SOFTMAX;
};

template<> struct LayerTraits<nn::FULLY_CONNECTED> {
  static const Layer enum_value = Layer::FULLY_CONNECTED;
};

template<> struct LayerTraits<nn::ADD> {
  static const Layer enum_value = Layer::ADD;
};

template<> struct LayerTraits<nn::CONCATENATION> {
  static const Layer enum_value = Layer::CONCATENATION;
};

template<> struct LayerTraits<nn::DEPTHWISE_CONV_2D> {
  static const Layer enum_value = Layer::DEPTHWISE_CONV_2D;
};

template<> struct LayerTraits<nn::BATCH_TO_SPACE_ND> {
  static const Layer enum_value = Layer::BATCH_TO_SPACE_ND;
};

template<> struct LayerTraits<nn::SPACE_TO_BATCH_ND> {
  static const Layer enum_value = Layer::SPACE_TO_BATCH_ND;
};

template<> struct LayerTraits<nn::STRIDED_SLICE> {
  static const Layer enum_value = Layer::STRIDED_SLICE;
};

template<> struct LayerTraits<nn::MUL> {
  static const Layer enum_value = Layer::MUL;
};

template<> struct LayerTraits<nn::DEQUANTIZE> {
  static const Layer enum_value = Layer::DEQUANTIZE;
};

template<> struct LayerTraits<nn::LOCAL_RESPONSE_NORMALIZATION> {
  static const Layer enum_value = Layer::LOCAL_RESPONSE_NORMALIZATION;
};

template<> struct LayerTraits<nn::TANH> {
  static const Layer enum_value = Layer::TANH;
};

template<> struct LayerTraits<nn::FLOOR> {
  static const Layer enum_value = Layer::FLOOR;
};

template<> struct LayerTraits<nn::LOGISTIC> {
  static const Layer enum_value = Layer::LOGISTIC;
};

template<> struct LayerTraits<nn::PRELU> {
  static const Layer enum_value = Layer::PRELU;
};

template<> struct LayerTraits<nn::POW> {
  static const Layer enum_value = Layer::POW;
};

template<> struct LayerTraits<nn::NEG> {
  static const Layer enum_value = Layer::NEG;
};

template<> struct LayerTraits<nn::MINIMUM> {
  static const Layer enum_value = Layer::MINIMUM;
};

template<> struct LayerTraits<nn::MAXIMUM> {
  static const Layer enum_value = Layer::MAXIMUM;
};

template<> struct LayerTraits<nn::LOG> {
  static const Layer enum_value = Layer::LOG;
};

template<> struct LayerTraits<nn::ABS> {
  static const Layer enum_value = Layer::ABS;
};

template<> struct LayerTraits<nn::EXP> {
  static const Layer enum_value = Layer::EXP;
};

template<> struct LayerTraits<nn::SUB> {
  static const Layer enum_value = Layer::SUB;
};

template<> struct LayerTraits<nn::GATHER> {
  static const Layer enum_value = Layer::GATHER;
};

template<> struct LayerTraits<nn::RESHAPE> {
  static const Layer enum_value = Layer::RESHAPE;
};

template<> struct LayerTraits<nn::Configure> {
  static const Layer enum_value = Layer::Configure;
};

bool VerifyLayer(flatbuffers::Verifier &verifier, const void *obj, Layer type);
bool VerifyLayerVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<Layer> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) versionInfo FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t codeversion_;
  int64_t dataversion_;

 public:
  struct Traits;
  versionInfo()
      : codeversion_(0),
        dataversion_(0) {
  }
  versionInfo(uint64_t _codeversion, int64_t _dataversion)
      : codeversion_(flatbuffers::EndianScalar(_codeversion)),
        dataversion_(flatbuffers::EndianScalar(_dataversion)) {
  }
  uint64_t codeversion() const {
    return flatbuffers::EndianScalar(codeversion_);
  }
  int64_t dataversion() const {
    return flatbuffers::EndianScalar(dataversion_);
  }
};
FLATBUFFERS_STRUCT_END(versionInfo, 16);

struct versionInfo::Traits {
  using type = versionInfo;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Pads FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t left_;
  int32_t right_;
  int32_t top_;
  int32_t bottom_;

 public:
  struct Traits;
  Pads()
      : left_(0),
        right_(0),
        top_(0),
        bottom_(0) {
  }
  Pads(int32_t _left, int32_t _right, int32_t _top, int32_t _bottom)
      : left_(flatbuffers::EndianScalar(_left)),
        right_(flatbuffers::EndianScalar(_right)),
        top_(flatbuffers::EndianScalar(_top)),
        bottom_(flatbuffers::EndianScalar(_bottom)) {
  }
  int32_t left() const {
    return flatbuffers::EndianScalar(left_);
  }
  int32_t right() const {
    return flatbuffers::EndianScalar(right_);
  }
  int32_t top() const {
    return flatbuffers::EndianScalar(top_);
  }
  int32_t bottom() const {
    return flatbuffers::EndianScalar(bottom_);
  }
};
FLATBUFFERS_STRUCT_END(Pads, 16);

struct Pads::Traits {
  using type = Pads;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Stride FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;

 public:
  struct Traits;
  Stride()
      : x_(0),
        y_(0) {
  }
  Stride(int32_t _x, int32_t _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Stride, 8);

struct Stride::Traits {
  using type = Stride;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Dilation FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;

 public:
  struct Traits;
  Dilation()
      : x_(0),
        y_(0) {
  }
  Dilation(int32_t _x, int32_t _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Dilation, 8);

struct Dilation::Traits {
  using type = Dilation;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) KernelShape FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t width_;
  int32_t height_;

 public:
  struct Traits;
  KernelShape()
      : width_(0),
        height_(0) {
  }
  KernelShape(int32_t _width, int32_t _height)
      : width_(flatbuffers::EndianScalar(_width)),
        height_(flatbuffers::EndianScalar(_height)) {
  }
  int32_t width() const {
    return flatbuffers::EndianScalar(width_);
  }
  int32_t height() const {
    return flatbuffers::EndianScalar(height_);
  }
};
FLATBUFFERS_STRUCT_END(KernelShape, 8);

struct KernelShape::Traits {
  using type = KernelShape;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Group FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t id_;

 public:
  struct Traits;
  Group()
      : id_(0) {
  }
  Group(int32_t _id)
      : id_(flatbuffers::EndianScalar(_id)) {
  }
  int32_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
};
FLATBUFFERS_STRUCT_END(Group, 4);

struct Group::Traits {
  using type = Group;
};

struct TensorInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DATA_FUSE = 6,
    VT_DIM = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  nn::FuseCode data_fuse() const {
    return static_cast<nn::FuseCode>(GetField<int8_t>(VT_DATA_FUSE, 0));
  }
  const flatbuffers::Vector<uint16_t> *dim() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_DIM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_DATA_FUSE, 1) &&
           VerifyOffset(verifier, VT_DIM) &&
           verifier.VerifyVector(dim()) &&
           verifier.EndTable();
  }
};

struct TensorInfoBuilder {
  typedef TensorInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TensorInfo::VT_NAME, name);
  }
  void add_data_fuse(nn::FuseCode data_fuse) {
    fbb_.AddElement<int8_t>(TensorInfo::VT_DATA_FUSE, static_cast<int8_t>(data_fuse), 0);
  }
  void add_dim(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> dim) {
    fbb_.AddOffset(TensorInfo::VT_DIM, dim);
  }
  explicit TensorInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorInfo> CreateTensorInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    nn::FuseCode data_fuse = nn::FuseCode::Relu,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> dim = 0) {
  TensorInfoBuilder builder_(_fbb);
  builder_.add_dim(dim);
  builder_.add_name(name);
  builder_.add_data_fuse(data_fuse);
  return builder_.Finish();
}

struct TensorInfo::Traits {
  using type = TensorInfo;
  static auto constexpr Create = CreateTensorInfo;
};

inline flatbuffers::Offset<TensorInfo> CreateTensorInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    nn::FuseCode data_fuse = nn::FuseCode::Relu,
    const std::vector<uint16_t> *dim = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto dim__ = dim ? _fbb.CreateVector<uint16_t>(*dim) : 0;
  return nn::CreateTensorInfo(
      _fbb,
      name__,
      data_fuse,
      dim__);
}

struct rawTensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef rawTensorBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4,
    VT_DATA = 6
  };
  const nn::TensorInfo *info() const {
    return GetPointer<const nn::TensorInfo *>(VT_INFO);
  }
  const flatbuffers::String *data() const {
    return GetPointer<const flatbuffers::String *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyString(data()) &&
           verifier.EndTable();
  }
};

struct rawTensorBuilder {
  typedef rawTensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<nn::TensorInfo> info) {
    fbb_.AddOffset(rawTensor::VT_INFO, info);
  }
  void add_data(flatbuffers::Offset<flatbuffers::String> data) {
    fbb_.AddOffset(rawTensor::VT_DATA, data);
  }
  explicit rawTensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<rawTensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<rawTensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<rawTensor> CreaterawTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    flatbuffers::Offset<flatbuffers::String> data = 0) {
  rawTensorBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_info(info);
  return builder_.Finish();
}

struct rawTensor::Traits {
  using type = rawTensor;
  static auto constexpr Create = CreaterawTensor;
};

inline flatbuffers::Offset<rawTensor> CreaterawTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    const char *data = nullptr) {
  auto data__ = data ? _fbb.CreateString(data) : 0;
  return nn::CreaterawTensor(
      _fbb,
      info,
      data__);
}

struct i8Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef i8TensorBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4,
    VT_DATA = 6
  };
  const nn::TensorInfo *info() const {
    return GetPointer<const nn::TensorInfo *>(VT_INFO);
  }
  const flatbuffers::Vector<int8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct i8TensorBuilder {
  typedef i8Tensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<nn::TensorInfo> info) {
    fbb_.AddOffset(i8Tensor::VT_INFO, info);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<int8_t>> data) {
    fbb_.AddOffset(i8Tensor::VT_DATA, data);
  }
  explicit i8TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<i8Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<i8Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<i8Tensor> Createi8Tensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> data = 0) {
  i8TensorBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_info(info);
  return builder_.Finish();
}

struct i8Tensor::Traits {
  using type = i8Tensor;
  static auto constexpr Create = Createi8Tensor;
};

inline flatbuffers::Offset<i8Tensor> Createi8TensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    const std::vector<int8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<int8_t>(*data) : 0;
  return nn::Createi8Tensor(
      _fbb,
      info,
      data__);
}

struct i16Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef i16TensorBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4,
    VT_DATA = 6
  };
  const nn::TensorInfo *info() const {
    return GetPointer<const nn::TensorInfo *>(VT_INFO);
  }
  const flatbuffers::Vector<int16_t> *data() const {
    return GetPointer<const flatbuffers::Vector<int16_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct i16TensorBuilder {
  typedef i16Tensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<nn::TensorInfo> info) {
    fbb_.AddOffset(i16Tensor::VT_INFO, info);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<int16_t>> data) {
    fbb_.AddOffset(i16Tensor::VT_DATA, data);
  }
  explicit i16TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<i16Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<i16Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<i16Tensor> Createi16Tensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<int16_t>> data = 0) {
  i16TensorBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_info(info);
  return builder_.Finish();
}

struct i16Tensor::Traits {
  using type = i16Tensor;
  static auto constexpr Create = Createi16Tensor;
};

inline flatbuffers::Offset<i16Tensor> Createi16TensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    const std::vector<int16_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<int16_t>(*data) : 0;
  return nn::Createi16Tensor(
      _fbb,
      info,
      data__);
}

struct i32Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef i32TensorBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4,
    VT_DATA = 6
  };
  const nn::TensorInfo *info() const {
    return GetPointer<const nn::TensorInfo *>(VT_INFO);
  }
  const flatbuffers::Vector<int32_t> *data() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct i32TensorBuilder {
  typedef i32Tensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<nn::TensorInfo> info) {
    fbb_.AddOffset(i32Tensor::VT_INFO, info);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<int32_t>> data) {
    fbb_.AddOffset(i32Tensor::VT_DATA, data);
  }
  explicit i32TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<i32Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<i32Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<i32Tensor> Createi32Tensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> data = 0) {
  i32TensorBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_info(info);
  return builder_.Finish();
}

struct i32Tensor::Traits {
  using type = i32Tensor;
  static auto constexpr Create = Createi32Tensor;
};

inline flatbuffers::Offset<i32Tensor> Createi32TensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    const std::vector<int32_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<int32_t>(*data) : 0;
  return nn::Createi32Tensor(
      _fbb,
      info,
      data__);
}

struct i64Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef i64TensorBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4,
    VT_DATA = 6
  };
  const nn::TensorInfo *info() const {
    return GetPointer<const nn::TensorInfo *>(VT_INFO);
  }
  const flatbuffers::Vector<int64_t> *data() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct i64TensorBuilder {
  typedef i64Tensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<nn::TensorInfo> info) {
    fbb_.AddOffset(i64Tensor::VT_INFO, info);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<int64_t>> data) {
    fbb_.AddOffset(i64Tensor::VT_DATA, data);
  }
  explicit i64TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<i64Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<i64Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<i64Tensor> Createi64Tensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> data = 0) {
  i64TensorBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_info(info);
  return builder_.Finish();
}

struct i64Tensor::Traits {
  using type = i64Tensor;
  static auto constexpr Create = Createi64Tensor;
};

inline flatbuffers::Offset<i64Tensor> Createi64TensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    const std::vector<int64_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<int64_t>(*data) : 0;
  return nn::Createi64Tensor(
      _fbb,
      info,
      data__);
}

struct f16Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef f16TensorBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4,
    VT_DATA = 6
  };
  const nn::TensorInfo *info() const {
    return GetPointer<const nn::TensorInfo *>(VT_INFO);
  }
  const flatbuffers::Vector<uint16_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct f16TensorBuilder {
  typedef f16Tensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<nn::TensorInfo> info) {
    fbb_.AddOffset(f16Tensor::VT_INFO, info);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> data) {
    fbb_.AddOffset(f16Tensor::VT_DATA, data);
  }
  explicit f16TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<f16Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<f16Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<f16Tensor> Createf16Tensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> data = 0) {
  f16TensorBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_info(info);
  return builder_.Finish();
}

struct f16Tensor::Traits {
  using type = f16Tensor;
  static auto constexpr Create = Createf16Tensor;
};

inline flatbuffers::Offset<f16Tensor> Createf16TensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    const std::vector<uint16_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint16_t>(*data) : 0;
  return nn::Createf16Tensor(
      _fbb,
      info,
      data__);
}

struct f32Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef f32TensorBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4,
    VT_DATA = 6
  };
  const nn::TensorInfo *info() const {
    return GetPointer<const nn::TensorInfo *>(VT_INFO);
  }
  const flatbuffers::Vector<float> *data() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct f32TensorBuilder {
  typedef f32Tensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<nn::TensorInfo> info) {
    fbb_.AddOffset(f32Tensor::VT_INFO, info);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<float>> data) {
    fbb_.AddOffset(f32Tensor::VT_DATA, data);
  }
  explicit f32TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<f32Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<f32Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<f32Tensor> Createf32Tensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> data = 0) {
  f32TensorBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_info(info);
  return builder_.Finish();
}

struct f32Tensor::Traits {
  using type = f32Tensor;
  static auto constexpr Create = Createf32Tensor;
};

inline flatbuffers::Offset<f32Tensor> Createf32TensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    const std::vector<float> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<float>(*data) : 0;
  return nn::Createf32Tensor(
      _fbb,
      info,
      data__);
}

struct f64Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef f64TensorBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4,
    VT_DATA = 6
  };
  const nn::TensorInfo *info() const {
    return GetPointer<const nn::TensorInfo *>(VT_INFO);
  }
  const flatbuffers::Vector<double> *data() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct f64TensorBuilder {
  typedef f64Tensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<nn::TensorInfo> info) {
    fbb_.AddOffset(f64Tensor::VT_INFO, info);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<double>> data) {
    fbb_.AddOffset(f64Tensor::VT_DATA, data);
  }
  explicit f64TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<f64Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<f64Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<f64Tensor> Createf64Tensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> data = 0) {
  f64TensorBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_info(info);
  return builder_.Finish();
}

struct f64Tensor::Traits {
  using type = f64Tensor;
  static auto constexpr Create = Createf64Tensor;
};

inline flatbuffers::Offset<f64Tensor> Createf64TensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    const std::vector<double> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<double>(*data) : 0;
  return nn::Createf64Tensor(
      _fbb,
      info,
      data__);
}

struct QuantInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuantInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_DIM = 8,
    VT_SCALES = 10,
    VT_ZERO_POINT = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  nn::DataType type() const {
    return static_cast<nn::DataType>(GetField<int8_t>(VT_TYPE, 0));
  }
  uint16_t dim() const {
    return GetField<uint16_t>(VT_DIM, 0);
  }
  const flatbuffers::Vector<float> *scales() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALES);
  }
  int32_t zero_point() const {
    return GetField<int32_t>(VT_ZERO_POINT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint16_t>(verifier, VT_DIM, 2) &&
           VerifyOffset(verifier, VT_SCALES) &&
           verifier.VerifyVector(scales()) &&
           VerifyField<int32_t>(verifier, VT_ZERO_POINT, 4) &&
           verifier.EndTable();
  }
};

struct QuantInfoBuilder {
  typedef QuantInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(QuantInfo::VT_NAME, name);
  }
  void add_type(nn::DataType type) {
    fbb_.AddElement<int8_t>(QuantInfo::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_dim(uint16_t dim) {
    fbb_.AddElement<uint16_t>(QuantInfo::VT_DIM, dim, 0);
  }
  void add_scales(flatbuffers::Offset<flatbuffers::Vector<float>> scales) {
    fbb_.AddOffset(QuantInfo::VT_SCALES, scales);
  }
  void add_zero_point(int32_t zero_point) {
    fbb_.AddElement<int32_t>(QuantInfo::VT_ZERO_POINT, zero_point, 0);
  }
  explicit QuantInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<QuantInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantInfo>(end);
    fbb_.Required(o, QuantInfo::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<QuantInfo> CreateQuantInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    nn::DataType type = nn::DataType::Float,
    uint16_t dim = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scales = 0,
    int32_t zero_point = 0) {
  QuantInfoBuilder builder_(_fbb);
  builder_.add_zero_point(zero_point);
  builder_.add_scales(scales);
  builder_.add_name(name);
  builder_.add_dim(dim);
  builder_.add_type(type);
  return builder_.Finish();
}

struct QuantInfo::Traits {
  using type = QuantInfo;
  static auto constexpr Create = CreateQuantInfo;
};

inline flatbuffers::Offset<QuantInfo> CreateQuantInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    nn::DataType type = nn::DataType::Float,
    uint16_t dim = 0,
    const std::vector<float> *scales = nullptr,
    int32_t zero_point = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto scales__ = scales ? _fbb.CreateVector<float>(*scales) : 0;
  return nn::CreateQuantInfo(
      _fbb,
      name__,
      type,
      dim,
      scales__,
      zero_point);
}

struct InputTensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InputTensorBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_DIM = 6
  };
  nn::DataType type() const {
    return static_cast<nn::DataType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<uint16_t> *dim() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_DIM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_DIM) &&
           verifier.VerifyVector(dim()) &&
           verifier.EndTable();
  }
};

struct InputTensorBuilder {
  typedef InputTensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(nn::DataType type) {
    fbb_.AddElement<int8_t>(InputTensor::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_dim(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> dim) {
    fbb_.AddOffset(InputTensor::VT_DIM, dim);
  }
  explicit InputTensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InputTensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InputTensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<InputTensor> CreateInputTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    nn::DataType type = nn::DataType::Float,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> dim = 0) {
  InputTensorBuilder builder_(_fbb);
  builder_.add_dim(dim);
  builder_.add_type(type);
  return builder_.Finish();
}

struct InputTensor::Traits {
  using type = InputTensor;
  static auto constexpr Create = CreateInputTensor;
};

inline flatbuffers::Offset<InputTensor> CreateInputTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    nn::DataType type = nn::DataType::Float,
    const std::vector<uint16_t> *dim = nullptr) {
  auto dim__ = dim ? _fbb.CreateVector<uint16_t>(*dim) : 0;
  return nn::CreateInputTensor(
      _fbb,
      type,
      dim__);
}

struct LinkOd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LinkOdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_OUTPUT = 6,
    VT_NAME = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *input() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_INPUT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *output() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_OUTPUT);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_INPUT) &&
           verifier.VerifyVector(input()) &&
           verifier.VerifyVectorOfStrings(input()) &&
           VerifyOffsetRequired(verifier, VT_OUTPUT) &&
           verifier.VerifyVector(output()) &&
           verifier.VerifyVectorOfStrings(output()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct LinkOdBuilder {
  typedef LinkOd Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> input) {
    fbb_.AddOffset(LinkOd::VT_INPUT, input);
  }
  void add_output(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> output) {
    fbb_.AddOffset(LinkOd::VT_OUTPUT, output);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(LinkOd::VT_NAME, name);
  }
  explicit LinkOdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LinkOd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LinkOd>(end);
    fbb_.Required(o, LinkOd::VT_INPUT);
    fbb_.Required(o, LinkOd::VT_OUTPUT);
    return o;
  }
};

inline flatbuffers::Offset<LinkOd> CreateLinkOd(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> input = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> output = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  LinkOdBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_output(output);
  builder_.add_input(input);
  return builder_.Finish();
}

struct LinkOd::Traits {
  using type = LinkOd;
  static auto constexpr Create = CreateLinkOd;
};

inline flatbuffers::Offset<LinkOd> CreateLinkOdDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *input = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *output = nullptr,
    const char *name = nullptr) {
  auto input__ = input ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*input) : 0;
  auto output__ = output ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*output) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return nn::CreateLinkOd(
      _fbb,
      input__,
      output__,
      name__);
}

struct Link FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LinkBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_EXT_OUTPUT = 6,
    VT_NAME = 8
  };
  const flatbuffers::Vector<uint32_t> *input() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INPUT);
  }
  const flatbuffers::Vector<uint32_t> *ext_output() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_EXT_OUTPUT);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_INPUT) &&
           verifier.VerifyVector(input()) &&
           VerifyOffset(verifier, VT_EXT_OUTPUT) &&
           verifier.VerifyVector(ext_output()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct LinkBuilder {
  typedef Link Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> input) {
    fbb_.AddOffset(Link::VT_INPUT, input);
  }
  void add_ext_output(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> ext_output) {
    fbb_.AddOffset(Link::VT_EXT_OUTPUT, ext_output);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Link::VT_NAME, name);
  }
  explicit LinkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Link> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Link>(end);
    fbb_.Required(o, Link::VT_INPUT);
    return o;
  }
};

inline flatbuffers::Offset<Link> CreateLink(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> input = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> ext_output = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  LinkBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_ext_output(ext_output);
  builder_.add_input(input);
  return builder_.Finish();
}

struct Link::Traits {
  using type = Link;
  static auto constexpr Create = CreateLink;
};

inline flatbuffers::Offset<Link> CreateLinkDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *input = nullptr,
    const std::vector<uint32_t> *ext_output = nullptr,
    const char *name = nullptr) {
  auto input__ = input ? _fbb.CreateVector<uint32_t>(*input) : 0;
  auto ext_output__ = ext_output ? _fbb.CreateVector<uint32_t>(*ext_output) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return nn::CreateLink(
      _fbb,
      input__,
      ext_output__,
      name__);
}

struct CONV_2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CONV_2DBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_PADDING = 6,
    VT_STRIDE = 8,
    VT_DILATION = 10,
    VT_GROUP = 12,
    VT_FUSE_CODE = 14
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const nn::Pads *padding() const {
    return GetStruct<const nn::Pads *>(VT_PADDING);
  }
  const nn::Stride *stride() const {
    return GetStruct<const nn::Stride *>(VT_STRIDE);
  }
  const nn::Dilation *dilation() const {
    return GetStruct<const nn::Dilation *>(VT_DILATION);
  }
  const nn::Group *group() const {
    return GetStruct<const nn::Group *>(VT_GROUP);
  }
  nn::FuseCode fuse_code() const {
    return static_cast<nn::FuseCode>(GetField<int8_t>(VT_FUSE_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<nn::Pads>(verifier, VT_PADDING, 4) &&
           VerifyField<nn::Stride>(verifier, VT_STRIDE, 4) &&
           VerifyField<nn::Dilation>(verifier, VT_DILATION, 4) &&
           VerifyField<nn::Group>(verifier, VT_GROUP, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSE_CODE, 1) &&
           verifier.EndTable();
  }
};

struct CONV_2DBuilder {
  typedef CONV_2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(CONV_2D::VT_LINK, link);
  }
  void add_padding(const nn::Pads *padding) {
    fbb_.AddStruct(CONV_2D::VT_PADDING, padding);
  }
  void add_stride(const nn::Stride *stride) {
    fbb_.AddStruct(CONV_2D::VT_STRIDE, stride);
  }
  void add_dilation(const nn::Dilation *dilation) {
    fbb_.AddStruct(CONV_2D::VT_DILATION, dilation);
  }
  void add_group(const nn::Group *group) {
    fbb_.AddStruct(CONV_2D::VT_GROUP, group);
  }
  void add_fuse_code(nn::FuseCode fuse_code) {
    fbb_.AddElement<int8_t>(CONV_2D::VT_FUSE_CODE, static_cast<int8_t>(fuse_code), 0);
  }
  explicit CONV_2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CONV_2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CONV_2D>(end);
    fbb_.Required(o, CONV_2D::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<CONV_2D> CreateCONV_2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const nn::Pads *padding = nullptr,
    const nn::Stride *stride = nullptr,
    const nn::Dilation *dilation = nullptr,
    const nn::Group *group = nullptr,
    nn::FuseCode fuse_code = nn::FuseCode::Relu) {
  CONV_2DBuilder builder_(_fbb);
  builder_.add_group(group);
  builder_.add_dilation(dilation);
  builder_.add_stride(stride);
  builder_.add_padding(padding);
  builder_.add_link(link);
  builder_.add_fuse_code(fuse_code);
  return builder_.Finish();
}

struct CONV_2D::Traits {
  using type = CONV_2D;
  static auto constexpr Create = CreateCONV_2D;
};

struct AVERAGE_POOL_2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AVERAGE_POOL_2DBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_PADDING = 6,
    VT_STRIDE = 8,
    VT_KERNEL_SHAPE = 10,
    VT_FUSE_CODE = 12
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const nn::Pads *padding() const {
    return GetStruct<const nn::Pads *>(VT_PADDING);
  }
  const nn::Stride *stride() const {
    return GetStruct<const nn::Stride *>(VT_STRIDE);
  }
  const nn::KernelShape *kernel_shape() const {
    return GetStruct<const nn::KernelShape *>(VT_KERNEL_SHAPE);
  }
  nn::FuseCode fuse_code() const {
    return static_cast<nn::FuseCode>(GetField<int8_t>(VT_FUSE_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<nn::Pads>(verifier, VT_PADDING, 4) &&
           VerifyField<nn::Stride>(verifier, VT_STRIDE, 4) &&
           VerifyField<nn::KernelShape>(verifier, VT_KERNEL_SHAPE, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSE_CODE, 1) &&
           verifier.EndTable();
  }
};

struct AVERAGE_POOL_2DBuilder {
  typedef AVERAGE_POOL_2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(AVERAGE_POOL_2D::VT_LINK, link);
  }
  void add_padding(const nn::Pads *padding) {
    fbb_.AddStruct(AVERAGE_POOL_2D::VT_PADDING, padding);
  }
  void add_stride(const nn::Stride *stride) {
    fbb_.AddStruct(AVERAGE_POOL_2D::VT_STRIDE, stride);
  }
  void add_kernel_shape(const nn::KernelShape *kernel_shape) {
    fbb_.AddStruct(AVERAGE_POOL_2D::VT_KERNEL_SHAPE, kernel_shape);
  }
  void add_fuse_code(nn::FuseCode fuse_code) {
    fbb_.AddElement<int8_t>(AVERAGE_POOL_2D::VT_FUSE_CODE, static_cast<int8_t>(fuse_code), 0);
  }
  explicit AVERAGE_POOL_2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AVERAGE_POOL_2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AVERAGE_POOL_2D>(end);
    fbb_.Required(o, AVERAGE_POOL_2D::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<AVERAGE_POOL_2D> CreateAVERAGE_POOL_2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const nn::Pads *padding = nullptr,
    const nn::Stride *stride = nullptr,
    const nn::KernelShape *kernel_shape = nullptr,
    nn::FuseCode fuse_code = nn::FuseCode::Relu) {
  AVERAGE_POOL_2DBuilder builder_(_fbb);
  builder_.add_kernel_shape(kernel_shape);
  builder_.add_stride(stride);
  builder_.add_padding(padding);
  builder_.add_link(link);
  builder_.add_fuse_code(fuse_code);
  return builder_.Finish();
}

struct AVERAGE_POOL_2D::Traits {
  using type = AVERAGE_POOL_2D;
  static auto constexpr Create = CreateAVERAGE_POOL_2D;
};

struct MAX_POOL_2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MAX_POOL_2DBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_PADDING = 6,
    VT_STRIDE = 8,
    VT_KERNEL_SHAPE = 10,
    VT_FUSE_CODE = 12
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const nn::Pads *padding() const {
    return GetStruct<const nn::Pads *>(VT_PADDING);
  }
  const nn::Stride *stride() const {
    return GetStruct<const nn::Stride *>(VT_STRIDE);
  }
  const nn::KernelShape *kernel_shape() const {
    return GetStruct<const nn::KernelShape *>(VT_KERNEL_SHAPE);
  }
  nn::FuseCode fuse_code() const {
    return static_cast<nn::FuseCode>(GetField<int8_t>(VT_FUSE_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<nn::Pads>(verifier, VT_PADDING, 4) &&
           VerifyField<nn::Stride>(verifier, VT_STRIDE, 4) &&
           VerifyField<nn::KernelShape>(verifier, VT_KERNEL_SHAPE, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSE_CODE, 1) &&
           verifier.EndTable();
  }
};

struct MAX_POOL_2DBuilder {
  typedef MAX_POOL_2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(MAX_POOL_2D::VT_LINK, link);
  }
  void add_padding(const nn::Pads *padding) {
    fbb_.AddStruct(MAX_POOL_2D::VT_PADDING, padding);
  }
  void add_stride(const nn::Stride *stride) {
    fbb_.AddStruct(MAX_POOL_2D::VT_STRIDE, stride);
  }
  void add_kernel_shape(const nn::KernelShape *kernel_shape) {
    fbb_.AddStruct(MAX_POOL_2D::VT_KERNEL_SHAPE, kernel_shape);
  }
  void add_fuse_code(nn::FuseCode fuse_code) {
    fbb_.AddElement<int8_t>(MAX_POOL_2D::VT_FUSE_CODE, static_cast<int8_t>(fuse_code), 0);
  }
  explicit MAX_POOL_2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MAX_POOL_2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MAX_POOL_2D>(end);
    fbb_.Required(o, MAX_POOL_2D::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<MAX_POOL_2D> CreateMAX_POOL_2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const nn::Pads *padding = nullptr,
    const nn::Stride *stride = nullptr,
    const nn::KernelShape *kernel_shape = nullptr,
    nn::FuseCode fuse_code = nn::FuseCode::Relu) {
  MAX_POOL_2DBuilder builder_(_fbb);
  builder_.add_kernel_shape(kernel_shape);
  builder_.add_stride(stride);
  builder_.add_padding(padding);
  builder_.add_link(link);
  builder_.add_fuse_code(fuse_code);
  return builder_.Finish();
}

struct MAX_POOL_2D::Traits {
  using type = MAX_POOL_2D;
  static auto constexpr Create = CreateMAX_POOL_2D;
};

struct RELU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RELUBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct RELUBuilder {
  typedef RELU Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(RELU::VT_LINK, link);
  }
  explicit RELUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RELU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RELU>(end);
    fbb_.Required(o, RELU::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<RELU> CreateRELU(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  RELUBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct RELU::Traits {
  using type = RELU;
  static auto constexpr Create = CreateRELU;
};

struct SOFTMAX FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SOFTMAXBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_BETA = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<float>(verifier, VT_BETA, 4) &&
           verifier.EndTable();
  }
};

struct SOFTMAXBuilder {
  typedef SOFTMAX Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(SOFTMAX::VT_LINK, link);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(SOFTMAX::VT_BETA, beta, 0.0f);
  }
  explicit SOFTMAXBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SOFTMAX> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SOFTMAX>(end);
    fbb_.Required(o, SOFTMAX::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<SOFTMAX> CreateSOFTMAX(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    float beta = 0.0f) {
  SOFTMAXBuilder builder_(_fbb);
  builder_.add_beta(beta);
  builder_.add_link(link);
  return builder_.Finish();
}

struct SOFTMAX::Traits {
  using type = SOFTMAX;
  static auto constexpr Create = CreateSOFTMAX;
};

struct FULLY_CONNECTED FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FULLY_CONNECTEDBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_BIAS = 6,
    VT_FUSE_CODE = 8
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  float bias() const {
    return GetField<float>(VT_BIAS, 0.0f);
  }
  nn::FuseCode fuse_code() const {
    return static_cast<nn::FuseCode>(GetField<int8_t>(VT_FUSE_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<float>(verifier, VT_BIAS, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSE_CODE, 1) &&
           verifier.EndTable();
  }
};

struct FULLY_CONNECTEDBuilder {
  typedef FULLY_CONNECTED Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(FULLY_CONNECTED::VT_LINK, link);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(FULLY_CONNECTED::VT_BIAS, bias, 0.0f);
  }
  void add_fuse_code(nn::FuseCode fuse_code) {
    fbb_.AddElement<int8_t>(FULLY_CONNECTED::VT_FUSE_CODE, static_cast<int8_t>(fuse_code), 0);
  }
  explicit FULLY_CONNECTEDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FULLY_CONNECTED> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FULLY_CONNECTED>(end);
    fbb_.Required(o, FULLY_CONNECTED::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<FULLY_CONNECTED> CreateFULLY_CONNECTED(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    float bias = 0.0f,
    nn::FuseCode fuse_code = nn::FuseCode::Relu) {
  FULLY_CONNECTEDBuilder builder_(_fbb);
  builder_.add_bias(bias);
  builder_.add_link(link);
  builder_.add_fuse_code(fuse_code);
  return builder_.Finish();
}

struct FULLY_CONNECTED::Traits {
  using type = FULLY_CONNECTED;
  static auto constexpr Create = CreateFULLY_CONNECTED;
};

struct ADD FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ADDBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_FUSE_CODE = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  nn::FuseCode fuse_code() const {
    return static_cast<nn::FuseCode>(GetField<int8_t>(VT_FUSE_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<int8_t>(verifier, VT_FUSE_CODE, 1) &&
           verifier.EndTable();
  }
};

struct ADDBuilder {
  typedef ADD Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(ADD::VT_LINK, link);
  }
  void add_fuse_code(nn::FuseCode fuse_code) {
    fbb_.AddElement<int8_t>(ADD::VT_FUSE_CODE, static_cast<int8_t>(fuse_code), 0);
  }
  explicit ADDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ADD> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ADD>(end);
    fbb_.Required(o, ADD::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<ADD> CreateADD(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    nn::FuseCode fuse_code = nn::FuseCode::Relu) {
  ADDBuilder builder_(_fbb);
  builder_.add_link(link);
  builder_.add_fuse_code(fuse_code);
  return builder_.Finish();
}

struct ADD::Traits {
  using type = ADD;
  static auto constexpr Create = CreateADD;
};

struct SUB FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SUBBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_FUSE_CODE = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  nn::FuseCode fuse_code() const {
    return static_cast<nn::FuseCode>(GetField<int8_t>(VT_FUSE_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<int8_t>(verifier, VT_FUSE_CODE, 1) &&
           verifier.EndTable();
  }
};

struct SUBBuilder {
  typedef SUB Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(SUB::VT_LINK, link);
  }
  void add_fuse_code(nn::FuseCode fuse_code) {
    fbb_.AddElement<int8_t>(SUB::VT_FUSE_CODE, static_cast<int8_t>(fuse_code), 0);
  }
  explicit SUBBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SUB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SUB>(end);
    fbb_.Required(o, SUB::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<SUB> CreateSUB(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    nn::FuseCode fuse_code = nn::FuseCode::Relu) {
  SUBBuilder builder_(_fbb);
  builder_.add_link(link);
  builder_.add_fuse_code(fuse_code);
  return builder_.Finish();
}

struct SUB::Traits {
  using type = SUB;
  static auto constexpr Create = CreateSUB;
};

struct MUL FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MULBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_FUSE_CODE = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  nn::FuseCode fuse_code() const {
    return static_cast<nn::FuseCode>(GetField<int8_t>(VT_FUSE_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<int8_t>(verifier, VT_FUSE_CODE, 1) &&
           verifier.EndTable();
  }
};

struct MULBuilder {
  typedef MUL Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(MUL::VT_LINK, link);
  }
  void add_fuse_code(nn::FuseCode fuse_code) {
    fbb_.AddElement<int8_t>(MUL::VT_FUSE_CODE, static_cast<int8_t>(fuse_code), 0);
  }
  explicit MULBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MUL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MUL>(end);
    fbb_.Required(o, MUL::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<MUL> CreateMUL(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    nn::FuseCode fuse_code = nn::FuseCode::Relu) {
  MULBuilder builder_(_fbb);
  builder_.add_link(link);
  builder_.add_fuse_code(fuse_code);
  return builder_.Finish();
}

struct MUL::Traits {
  using type = MUL;
  static auto constexpr Create = CreateMUL;
};

struct CONCATENATION FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CONCATENATIONBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_AXIS = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
};

struct CONCATENATIONBuilder {
  typedef CONCATENATION Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(CONCATENATION::VT_LINK, link);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(CONCATENATION::VT_AXIS, axis, 0);
  }
  explicit CONCATENATIONBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CONCATENATION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CONCATENATION>(end);
    fbb_.Required(o, CONCATENATION::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<CONCATENATION> CreateCONCATENATION(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    int32_t axis = 0) {
  CONCATENATIONBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_link(link);
  return builder_.Finish();
}

struct CONCATENATION::Traits {
  using type = CONCATENATION;
  static auto constexpr Create = CreateCONCATENATION;
};

struct DEPTHWISE_CONV_2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DEPTHWISE_CONV_2DBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_PADDING = 6,
    VT_STRIDE = 8,
    VT_DEPTH_MULTIPLIER = 10,
    VT_FUSE_CODE = 12
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const nn::Pads *padding() const {
    return GetStruct<const nn::Pads *>(VT_PADDING);
  }
  const nn::Stride *stride() const {
    return GetStruct<const nn::Stride *>(VT_STRIDE);
  }
  int32_t depth_multiplier() const {
    return GetField<int32_t>(VT_DEPTH_MULTIPLIER, 0);
  }
  nn::FuseCode fuse_code() const {
    return static_cast<nn::FuseCode>(GetField<int8_t>(VT_FUSE_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<nn::Pads>(verifier, VT_PADDING, 4) &&
           VerifyField<nn::Stride>(verifier, VT_STRIDE, 4) &&
           VerifyField<int32_t>(verifier, VT_DEPTH_MULTIPLIER, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSE_CODE, 1) &&
           verifier.EndTable();
  }
};

struct DEPTHWISE_CONV_2DBuilder {
  typedef DEPTHWISE_CONV_2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(DEPTHWISE_CONV_2D::VT_LINK, link);
  }
  void add_padding(const nn::Pads *padding) {
    fbb_.AddStruct(DEPTHWISE_CONV_2D::VT_PADDING, padding);
  }
  void add_stride(const nn::Stride *stride) {
    fbb_.AddStruct(DEPTHWISE_CONV_2D::VT_STRIDE, stride);
  }
  void add_depth_multiplier(int32_t depth_multiplier) {
    fbb_.AddElement<int32_t>(DEPTHWISE_CONV_2D::VT_DEPTH_MULTIPLIER, depth_multiplier, 0);
  }
  void add_fuse_code(nn::FuseCode fuse_code) {
    fbb_.AddElement<int8_t>(DEPTHWISE_CONV_2D::VT_FUSE_CODE, static_cast<int8_t>(fuse_code), 0);
  }
  explicit DEPTHWISE_CONV_2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DEPTHWISE_CONV_2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DEPTHWISE_CONV_2D>(end);
    fbb_.Required(o, DEPTHWISE_CONV_2D::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<DEPTHWISE_CONV_2D> CreateDEPTHWISE_CONV_2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const nn::Pads *padding = nullptr,
    const nn::Stride *stride = nullptr,
    int32_t depth_multiplier = 0,
    nn::FuseCode fuse_code = nn::FuseCode::Relu) {
  DEPTHWISE_CONV_2DBuilder builder_(_fbb);
  builder_.add_depth_multiplier(depth_multiplier);
  builder_.add_stride(stride);
  builder_.add_padding(padding);
  builder_.add_link(link);
  builder_.add_fuse_code(fuse_code);
  return builder_.Finish();
}

struct DEPTHWISE_CONV_2D::Traits {
  using type = DEPTHWISE_CONV_2D;
  static auto constexpr Create = CreateDEPTHWISE_CONV_2D;
};

struct BATCH_TO_SPACE_ND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BATCH_TO_SPACE_NDBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_BLOCK_SIZES = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const flatbuffers::Vector<int32_t> *block_sizes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCK_SIZES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyOffset(verifier, VT_BLOCK_SIZES) &&
           verifier.VerifyVector(block_sizes()) &&
           verifier.EndTable();
  }
};

struct BATCH_TO_SPACE_NDBuilder {
  typedef BATCH_TO_SPACE_ND Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(BATCH_TO_SPACE_ND::VT_LINK, link);
  }
  void add_block_sizes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_sizes) {
    fbb_.AddOffset(BATCH_TO_SPACE_ND::VT_BLOCK_SIZES, block_sizes);
  }
  explicit BATCH_TO_SPACE_NDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BATCH_TO_SPACE_ND> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BATCH_TO_SPACE_ND>(end);
    fbb_.Required(o, BATCH_TO_SPACE_ND::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<BATCH_TO_SPACE_ND> CreateBATCH_TO_SPACE_ND(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_sizes = 0) {
  BATCH_TO_SPACE_NDBuilder builder_(_fbb);
  builder_.add_block_sizes(block_sizes);
  builder_.add_link(link);
  return builder_.Finish();
}

struct BATCH_TO_SPACE_ND::Traits {
  using type = BATCH_TO_SPACE_ND;
  static auto constexpr Create = CreateBATCH_TO_SPACE_ND;
};

inline flatbuffers::Offset<BATCH_TO_SPACE_ND> CreateBATCH_TO_SPACE_NDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const std::vector<int32_t> *block_sizes = nullptr) {
  auto block_sizes__ = block_sizes ? _fbb.CreateVector<int32_t>(*block_sizes) : 0;
  return nn::CreateBATCH_TO_SPACE_ND(
      _fbb,
      link,
      block_sizes__);
}

struct SPACE_TO_BATCH_ND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SPACE_TO_BATCH_NDBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_BLOCK_SIZES = 6,
    VT_PADDING = 8
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const flatbuffers::Vector<int32_t> *block_sizes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCK_SIZES);
  }
  const nn::Pads *padding() const {
    return GetStruct<const nn::Pads *>(VT_PADDING);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyOffset(verifier, VT_BLOCK_SIZES) &&
           verifier.VerifyVector(block_sizes()) &&
           VerifyField<nn::Pads>(verifier, VT_PADDING, 4) &&
           verifier.EndTable();
  }
};

struct SPACE_TO_BATCH_NDBuilder {
  typedef SPACE_TO_BATCH_ND Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(SPACE_TO_BATCH_ND::VT_LINK, link);
  }
  void add_block_sizes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_sizes) {
    fbb_.AddOffset(SPACE_TO_BATCH_ND::VT_BLOCK_SIZES, block_sizes);
  }
  void add_padding(const nn::Pads *padding) {
    fbb_.AddStruct(SPACE_TO_BATCH_ND::VT_PADDING, padding);
  }
  explicit SPACE_TO_BATCH_NDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SPACE_TO_BATCH_ND> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SPACE_TO_BATCH_ND>(end);
    fbb_.Required(o, SPACE_TO_BATCH_ND::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<SPACE_TO_BATCH_ND> CreateSPACE_TO_BATCH_ND(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_sizes = 0,
    const nn::Pads *padding = nullptr) {
  SPACE_TO_BATCH_NDBuilder builder_(_fbb);
  builder_.add_padding(padding);
  builder_.add_block_sizes(block_sizes);
  builder_.add_link(link);
  return builder_.Finish();
}

struct SPACE_TO_BATCH_ND::Traits {
  using type = SPACE_TO_BATCH_ND;
  static auto constexpr Create = CreateSPACE_TO_BATCH_ND;
};

inline flatbuffers::Offset<SPACE_TO_BATCH_ND> CreateSPACE_TO_BATCH_NDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const std::vector<int32_t> *block_sizes = nullptr,
    const nn::Pads *padding = nullptr) {
  auto block_sizes__ = block_sizes ? _fbb.CreateVector<int32_t>(*block_sizes) : 0;
  return nn::CreateSPACE_TO_BATCH_ND(
      _fbb,
      link,
      block_sizes__,
      padding);
}

struct STRIDED_SLICE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef STRIDED_SLICEBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_STARTS = 6,
    VT_ENDS = 8,
    VT_STRIDES = 10,
    VT_BEGIN_MASK = 12,
    VT_END_MASK = 14,
    VT_SHRINK_AXIS_MASK = 16
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const flatbuffers::Vector<int32_t> *starts() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STARTS);
  }
  const flatbuffers::Vector<int32_t> *ends() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ENDS);
  }
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  int32_t begin_mask() const {
    return GetField<int32_t>(VT_BEGIN_MASK, 0);
  }
  int32_t end_mask() const {
    return GetField<int32_t>(VT_END_MASK, 0);
  }
  int32_t shrink_axis_mask() const {
    return GetField<int32_t>(VT_SHRINK_AXIS_MASK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyOffset(verifier, VT_STARTS) &&
           verifier.VerifyVector(starts()) &&
           VerifyOffset(verifier, VT_ENDS) &&
           verifier.VerifyVector(ends()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyField<int32_t>(verifier, VT_BEGIN_MASK, 4) &&
           VerifyField<int32_t>(verifier, VT_END_MASK, 4) &&
           VerifyField<int32_t>(verifier, VT_SHRINK_AXIS_MASK, 4) &&
           verifier.EndTable();
  }
};

struct STRIDED_SLICEBuilder {
  typedef STRIDED_SLICE Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(STRIDED_SLICE::VT_LINK, link);
  }
  void add_starts(flatbuffers::Offset<flatbuffers::Vector<int32_t>> starts) {
    fbb_.AddOffset(STRIDED_SLICE::VT_STARTS, starts);
  }
  void add_ends(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ends) {
    fbb_.AddOffset(STRIDED_SLICE::VT_ENDS, ends);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(STRIDED_SLICE::VT_STRIDES, strides);
  }
  void add_begin_mask(int32_t begin_mask) {
    fbb_.AddElement<int32_t>(STRIDED_SLICE::VT_BEGIN_MASK, begin_mask, 0);
  }
  void add_end_mask(int32_t end_mask) {
    fbb_.AddElement<int32_t>(STRIDED_SLICE::VT_END_MASK, end_mask, 0);
  }
  void add_shrink_axis_mask(int32_t shrink_axis_mask) {
    fbb_.AddElement<int32_t>(STRIDED_SLICE::VT_SHRINK_AXIS_MASK, shrink_axis_mask, 0);
  }
  explicit STRIDED_SLICEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<STRIDED_SLICE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<STRIDED_SLICE>(end);
    fbb_.Required(o, STRIDED_SLICE::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<STRIDED_SLICE> CreateSTRIDED_SLICE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> starts = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ends = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0,
    int32_t begin_mask = 0,
    int32_t end_mask = 0,
    int32_t shrink_axis_mask = 0) {
  STRIDED_SLICEBuilder builder_(_fbb);
  builder_.add_shrink_axis_mask(shrink_axis_mask);
  builder_.add_end_mask(end_mask);
  builder_.add_begin_mask(begin_mask);
  builder_.add_strides(strides);
  builder_.add_ends(ends);
  builder_.add_starts(starts);
  builder_.add_link(link);
  return builder_.Finish();
}

struct STRIDED_SLICE::Traits {
  using type = STRIDED_SLICE;
  static auto constexpr Create = CreateSTRIDED_SLICE;
};

inline flatbuffers::Offset<STRIDED_SLICE> CreateSTRIDED_SLICEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const std::vector<int32_t> *starts = nullptr,
    const std::vector<int32_t> *ends = nullptr,
    const std::vector<int32_t> *strides = nullptr,
    int32_t begin_mask = 0,
    int32_t end_mask = 0,
    int32_t shrink_axis_mask = 0) {
  auto starts__ = starts ? _fbb.CreateVector<int32_t>(*starts) : 0;
  auto ends__ = ends ? _fbb.CreateVector<int32_t>(*ends) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  return nn::CreateSTRIDED_SLICE(
      _fbb,
      link,
      starts__,
      ends__,
      strides__,
      begin_mask,
      end_mask,
      shrink_axis_mask);
}

struct DEQUANTIZE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DEQUANTIZEBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct DEQUANTIZEBuilder {
  typedef DEQUANTIZE Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(DEQUANTIZE::VT_LINK, link);
  }
  explicit DEQUANTIZEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DEQUANTIZE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DEQUANTIZE>(end);
    fbb_.Required(o, DEQUANTIZE::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<DEQUANTIZE> CreateDEQUANTIZE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  DEQUANTIZEBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct DEQUANTIZE::Traits {
  using type = DEQUANTIZE;
  static auto constexpr Create = CreateDEQUANTIZE;
};

struct LOCAL_RESPONSE_NORMALIZATION FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LOCAL_RESPONSE_NORMALIZATIONBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_RADIUS = 6,
    VT_BIAS = 8,
    VT_ALPHA = 10,
    VT_BETA = 12
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  int32_t radius() const {
    return GetField<int32_t>(VT_RADIUS, 0);
  }
  float bias() const {
    return GetField<float>(VT_BIAS, 0.0f);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<int32_t>(verifier, VT_RADIUS, 4) &&
           VerifyField<float>(verifier, VT_BIAS, 4) &&
           VerifyField<float>(verifier, VT_ALPHA, 4) &&
           VerifyField<float>(verifier, VT_BETA, 4) &&
           verifier.EndTable();
  }
};

struct LOCAL_RESPONSE_NORMALIZATIONBuilder {
  typedef LOCAL_RESPONSE_NORMALIZATION Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(LOCAL_RESPONSE_NORMALIZATION::VT_LINK, link);
  }
  void add_radius(int32_t radius) {
    fbb_.AddElement<int32_t>(LOCAL_RESPONSE_NORMALIZATION::VT_RADIUS, radius, 0);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(LOCAL_RESPONSE_NORMALIZATION::VT_BIAS, bias, 0.0f);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LOCAL_RESPONSE_NORMALIZATION::VT_ALPHA, alpha, 0.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(LOCAL_RESPONSE_NORMALIZATION::VT_BETA, beta, 0.0f);
  }
  explicit LOCAL_RESPONSE_NORMALIZATIONBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LOCAL_RESPONSE_NORMALIZATION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LOCAL_RESPONSE_NORMALIZATION>(end);
    fbb_.Required(o, LOCAL_RESPONSE_NORMALIZATION::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<LOCAL_RESPONSE_NORMALIZATION> CreateLOCAL_RESPONSE_NORMALIZATION(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    int32_t radius = 0,
    float bias = 0.0f,
    float alpha = 0.0f,
    float beta = 0.0f) {
  LOCAL_RESPONSE_NORMALIZATIONBuilder builder_(_fbb);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_bias(bias);
  builder_.add_radius(radius);
  builder_.add_link(link);
  return builder_.Finish();
}

struct LOCAL_RESPONSE_NORMALIZATION::Traits {
  using type = LOCAL_RESPONSE_NORMALIZATION;
  static auto constexpr Create = CreateLOCAL_RESPONSE_NORMALIZATION;
};

struct TANH FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TANHBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct TANHBuilder {
  typedef TANH Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(TANH::VT_LINK, link);
  }
  explicit TANHBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TANH> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TANH>(end);
    fbb_.Required(o, TANH::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<TANH> CreateTANH(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  TANHBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct TANH::Traits {
  using type = TANH;
  static auto constexpr Create = CreateTANH;
};

struct FLOOR FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FLOORBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct FLOORBuilder {
  typedef FLOOR Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(FLOOR::VT_LINK, link);
  }
  explicit FLOORBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FLOOR> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FLOOR>(end);
    fbb_.Required(o, FLOOR::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<FLOOR> CreateFLOOR(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  FLOORBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct FLOOR::Traits {
  using type = FLOOR;
  static auto constexpr Create = CreateFLOOR;
};

struct LOGISTIC FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LOGISTICBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct LOGISTICBuilder {
  typedef LOGISTIC Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(LOGISTIC::VT_LINK, link);
  }
  explicit LOGISTICBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LOGISTIC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LOGISTIC>(end);
    fbb_.Required(o, LOGISTIC::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<LOGISTIC> CreateLOGISTIC(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  LOGISTICBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct LOGISTIC::Traits {
  using type = LOGISTIC;
  static auto constexpr Create = CreateLOGISTIC;
};

struct PRELU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PRELUBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_ALPHA = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const flatbuffers::String *alpha() const {
    return GetPointer<const flatbuffers::String *>(VT_ALPHA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyOffset(verifier, VT_ALPHA) &&
           verifier.VerifyString(alpha()) &&
           verifier.EndTable();
  }
};

struct PRELUBuilder {
  typedef PRELU Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(PRELU::VT_LINK, link);
  }
  void add_alpha(flatbuffers::Offset<flatbuffers::String> alpha) {
    fbb_.AddOffset(PRELU::VT_ALPHA, alpha);
  }
  explicit PRELUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PRELU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PRELU>(end);
    fbb_.Required(o, PRELU::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<PRELU> CreatePRELU(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    flatbuffers::Offset<flatbuffers::String> alpha = 0) {
  PRELUBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  builder_.add_link(link);
  return builder_.Finish();
}

struct PRELU::Traits {
  using type = PRELU;
  static auto constexpr Create = CreatePRELU;
};

inline flatbuffers::Offset<PRELU> CreatePRELUDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const char *alpha = nullptr) {
  auto alpha__ = alpha ? _fbb.CreateString(alpha) : 0;
  return nn::CreatePRELU(
      _fbb,
      link,
      alpha__);
}

struct POW FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef POWBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_EXP = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const flatbuffers::String *exp() const {
    return GetPointer<const flatbuffers::String *>(VT_EXP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyOffset(verifier, VT_EXP) &&
           verifier.VerifyString(exp()) &&
           verifier.EndTable();
  }
};

struct POWBuilder {
  typedef POW Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(POW::VT_LINK, link);
  }
  void add_exp(flatbuffers::Offset<flatbuffers::String> exp) {
    fbb_.AddOffset(POW::VT_EXP, exp);
  }
  explicit POWBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<POW> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<POW>(end);
    fbb_.Required(o, POW::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<POW> CreatePOW(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    flatbuffers::Offset<flatbuffers::String> exp = 0) {
  POWBuilder builder_(_fbb);
  builder_.add_exp(exp);
  builder_.add_link(link);
  return builder_.Finish();
}

struct POW::Traits {
  using type = POW;
  static auto constexpr Create = CreatePOW;
};

inline flatbuffers::Offset<POW> CreatePOWDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const char *exp = nullptr) {
  auto exp__ = exp ? _fbb.CreateString(exp) : 0;
  return nn::CreatePOW(
      _fbb,
      link,
      exp__);
}

struct NEG FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NEGBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct NEGBuilder {
  typedef NEG Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(NEG::VT_LINK, link);
  }
  explicit NEGBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NEG> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NEG>(end);
    fbb_.Required(o, NEG::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<NEG> CreateNEG(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  NEGBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct NEG::Traits {
  using type = NEG;
  static auto constexpr Create = CreateNEG;
};

struct MINIMUM FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MINIMUMBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct MINIMUMBuilder {
  typedef MINIMUM Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(MINIMUM::VT_LINK, link);
  }
  explicit MINIMUMBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MINIMUM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MINIMUM>(end);
    fbb_.Required(o, MINIMUM::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<MINIMUM> CreateMINIMUM(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  MINIMUMBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct MINIMUM::Traits {
  using type = MINIMUM;
  static auto constexpr Create = CreateMINIMUM;
};

struct MAXIMUM FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MAXIMUMBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct MAXIMUMBuilder {
  typedef MAXIMUM Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(MAXIMUM::VT_LINK, link);
  }
  explicit MAXIMUMBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MAXIMUM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MAXIMUM>(end);
    fbb_.Required(o, MAXIMUM::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<MAXIMUM> CreateMAXIMUM(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  MAXIMUMBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct MAXIMUM::Traits {
  using type = MAXIMUM;
  static auto constexpr Create = CreateMAXIMUM;
};

struct LOG FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LOGBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct LOGBuilder {
  typedef LOG Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(LOG::VT_LINK, link);
  }
  explicit LOGBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LOG> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LOG>(end);
    fbb_.Required(o, LOG::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<LOG> CreateLOG(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  LOGBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct LOG::Traits {
  using type = LOG;
  static auto constexpr Create = CreateLOG;
};

struct ABS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ABSBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct ABSBuilder {
  typedef ABS Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(ABS::VT_LINK, link);
  }
  explicit ABSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ABS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ABS>(end);
    fbb_.Required(o, ABS::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<ABS> CreateABS(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  ABSBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct ABS::Traits {
  using type = ABS;
  static auto constexpr Create = CreateABS;
};

struct EXP FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EXPBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct EXPBuilder {
  typedef EXP Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(EXP::VT_LINK, link);
  }
  explicit EXPBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EXP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EXP>(end);
    fbb_.Required(o, EXP::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<EXP> CreateEXP(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  EXPBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct EXP::Traits {
  using type = EXP;
  static auto constexpr Create = CreateEXP;
};

struct GATHER FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GATHERBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_AXIS = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
};

struct GATHERBuilder {
  typedef GATHER Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(GATHER::VT_LINK, link);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(GATHER::VT_AXIS, axis, 0);
  }
  explicit GATHERBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GATHER> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GATHER>(end);
    fbb_.Required(o, GATHER::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<GATHER> CreateGATHER(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    int32_t axis = 0) {
  GATHERBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_link(link);
  return builder_.Finish();
}

struct GATHER::Traits {
  using type = GATHER;
  static auto constexpr Create = CreateGATHER;
};

struct RESHAPE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RESHAPEBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_AXES = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const flatbuffers::Vector<int32_t> *axes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyOffset(verifier, VT_AXES) &&
           verifier.VerifyVector(axes()) &&
           verifier.EndTable();
  }
};

struct RESHAPEBuilder {
  typedef RESHAPE Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(RESHAPE::VT_LINK, link);
  }
  void add_axes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axes) {
    fbb_.AddOffset(RESHAPE::VT_AXES, axes);
  }
  explicit RESHAPEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RESHAPE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RESHAPE>(end);
    fbb_.Required(o, RESHAPE::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<RESHAPE> CreateRESHAPE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axes = 0) {
  RESHAPEBuilder builder_(_fbb);
  builder_.add_axes(axes);
  builder_.add_link(link);
  return builder_.Finish();
}

struct RESHAPE::Traits {
  using type = RESHAPE;
  static auto constexpr Create = CreateRESHAPE;
};

inline flatbuffers::Offset<RESHAPE> CreateRESHAPEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const std::vector<int32_t> *axes = nullptr) {
  auto axes__ = axes ? _fbb.CreateVector<int32_t>(*axes) : 0;
  return nn::CreateRESHAPE(
      _fbb,
      link,
      axes__);
}

struct Configure FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConfigureBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_GATHER_INDICES = 6,
    VT_GATHER_AXIS = 8,
    VT_UNSQUEEZE_AXES = 10,
    VT_CONCAT_AXIS = 12,
    VT_CONCAT = 14
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const flatbuffers::Vector<int32_t> *gather_indices() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_GATHER_INDICES);
  }
  int32_t gather_axis() const {
    return GetField<int32_t>(VT_GATHER_AXIS, 0);
  }
  const flatbuffers::Vector<int32_t> *unsqueeze_axes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_UNSQUEEZE_AXES);
  }
  int32_t concat_axis() const {
    return GetField<int32_t>(VT_CONCAT_AXIS, 0);
  }
  const flatbuffers::Vector<int32_t> *concat() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CONCAT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyOffset(verifier, VT_GATHER_INDICES) &&
           verifier.VerifyVector(gather_indices()) &&
           VerifyField<int32_t>(verifier, VT_GATHER_AXIS, 4) &&
           VerifyOffset(verifier, VT_UNSQUEEZE_AXES) &&
           verifier.VerifyVector(unsqueeze_axes()) &&
           VerifyField<int32_t>(verifier, VT_CONCAT_AXIS, 4) &&
           VerifyOffset(verifier, VT_CONCAT) &&
           verifier.VerifyVector(concat()) &&
           verifier.EndTable();
  }
};

struct ConfigureBuilder {
  typedef Configure Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(Configure::VT_LINK, link);
  }
  void add_gather_indices(flatbuffers::Offset<flatbuffers::Vector<int32_t>> gather_indices) {
    fbb_.AddOffset(Configure::VT_GATHER_INDICES, gather_indices);
  }
  void add_gather_axis(int32_t gather_axis) {
    fbb_.AddElement<int32_t>(Configure::VT_GATHER_AXIS, gather_axis, 0);
  }
  void add_unsqueeze_axes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> unsqueeze_axes) {
    fbb_.AddOffset(Configure::VT_UNSQUEEZE_AXES, unsqueeze_axes);
  }
  void add_concat_axis(int32_t concat_axis) {
    fbb_.AddElement<int32_t>(Configure::VT_CONCAT_AXIS, concat_axis, 0);
  }
  void add_concat(flatbuffers::Offset<flatbuffers::Vector<int32_t>> concat) {
    fbb_.AddOffset(Configure::VT_CONCAT, concat);
  }
  explicit ConfigureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Configure> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Configure>(end);
    fbb_.Required(o, Configure::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<Configure> CreateConfigure(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> gather_indices = 0,
    int32_t gather_axis = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> unsqueeze_axes = 0,
    int32_t concat_axis = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> concat = 0) {
  ConfigureBuilder builder_(_fbb);
  builder_.add_concat(concat);
  builder_.add_concat_axis(concat_axis);
  builder_.add_unsqueeze_axes(unsqueeze_axes);
  builder_.add_gather_axis(gather_axis);
  builder_.add_gather_indices(gather_indices);
  builder_.add_link(link);
  return builder_.Finish();
}

struct Configure::Traits {
  using type = Configure;
  static auto constexpr Create = CreateConfigure;
};

inline flatbuffers::Offset<Configure> CreateConfigureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const std::vector<int32_t> *gather_indices = nullptr,
    int32_t gather_axis = 0,
    const std::vector<int32_t> *unsqueeze_axes = nullptr,
    int32_t concat_axis = 0,
    const std::vector<int32_t> *concat = nullptr) {
  auto gather_indices__ = gather_indices ? _fbb.CreateVector<int32_t>(*gather_indices) : 0;
  auto unsqueeze_axes__ = unsqueeze_axes ? _fbb.CreateVector<int32_t>(*unsqueeze_axes) : 0;
  auto concat__ = concat ? _fbb.CreateVector<int32_t>(*concat) : 0;
  return nn::CreateConfigure(
      _fbb,
      link,
      gather_indices__,
      gather_axis,
      unsqueeze_axes__,
      concat_axis,
      concat__);
}

struct Graph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GraphBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_LINK = 6,
    VT_NODE_TYPE = 8,
    VT_NODE = 10,
    VT_QUANT_INFOS = 12
  };
  const nn::versionInfo *version() const {
    return GetStruct<const nn::versionInfo *>(VT_VERSION);
  }
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const flatbuffers::Vector<nn::Layer> *node_type() const {
    return GetPointer<const flatbuffers::Vector<nn::Layer> *>(VT_NODE_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *node() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_NODE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<nn::QuantInfo>> *quant_infos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<nn::QuantInfo>> *>(VT_QUANT_INFOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<nn::versionInfo>(verifier, VT_VERSION, 8) &&
           VerifyOffset(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyOffset(verifier, VT_NODE_TYPE) &&
           verifier.VerifyVector(node_type()) &&
           VerifyOffset(verifier, VT_NODE) &&
           verifier.VerifyVector(node()) &&
           VerifyLayerVector(verifier, node(), node_type()) &&
           VerifyOffset(verifier, VT_QUANT_INFOS) &&
           verifier.VerifyVector(quant_infos()) &&
           verifier.VerifyVectorOfTables(quant_infos()) &&
           verifier.EndTable();
  }
};

struct GraphBuilder {
  typedef Graph Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(const nn::versionInfo *version) {
    fbb_.AddStruct(Graph::VT_VERSION, version);
  }
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(Graph::VT_LINK, link);
  }
  void add_node_type(flatbuffers::Offset<flatbuffers::Vector<nn::Layer>> node_type) {
    fbb_.AddOffset(Graph::VT_NODE_TYPE, node_type);
  }
  void add_node(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> node) {
    fbb_.AddOffset(Graph::VT_NODE, node);
  }
  void add_quant_infos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<nn::QuantInfo>>> quant_infos) {
    fbb_.AddOffset(Graph::VT_QUANT_INFOS, quant_infos);
  }
  explicit GraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Graph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Graph>(end);
    return o;
  }
};

inline flatbuffers::Offset<Graph> CreateGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    const nn::versionInfo *version = nullptr,
    flatbuffers::Offset<nn::Link> link = 0,
    flatbuffers::Offset<flatbuffers::Vector<nn::Layer>> node_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> node = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<nn::QuantInfo>>> quant_infos = 0) {
  GraphBuilder builder_(_fbb);
  builder_.add_quant_infos(quant_infos);
  builder_.add_node(node);
  builder_.add_node_type(node_type);
  builder_.add_link(link);
  builder_.add_version(version);
  return builder_.Finish();
}

struct Graph::Traits {
  using type = Graph;
  static auto constexpr Create = CreateGraph;
};

inline flatbuffers::Offset<Graph> CreateGraphDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const nn::versionInfo *version = nullptr,
    flatbuffers::Offset<nn::Link> link = 0,
    const std::vector<nn::Layer> *node_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *node = nullptr,
    const std::vector<flatbuffers::Offset<nn::QuantInfo>> *quant_infos = nullptr) {
  auto node_type__ = node_type ? _fbb.CreateVector<nn::Layer>(*node_type) : 0;
  auto node__ = node ? _fbb.CreateVector<flatbuffers::Offset<void>>(*node) : 0;
  auto quant_infos__ = quant_infos ? _fbb.CreateVector<flatbuffers::Offset<nn::QuantInfo>>(*quant_infos) : 0;
  return nn::CreateGraph(
      _fbb,
      version,
      link,
      node_type__,
      node__,
      quant_infos__);
}

inline bool VerifyLayer(flatbuffers::Verifier &verifier, const void *obj, Layer type) {
  switch (type) {
    case Layer::NONE: {
      return true;
    }
    case Layer::InputTensor: {
      auto ptr = reinterpret_cast<const nn::InputTensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::rawTensor: {
      auto ptr = reinterpret_cast<const nn::rawTensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::i8Tensor: {
      auto ptr = reinterpret_cast<const nn::i8Tensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::i16Tensor: {
      auto ptr = reinterpret_cast<const nn::i16Tensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::i32Tensor: {
      auto ptr = reinterpret_cast<const nn::i32Tensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::i64Tensor: {
      auto ptr = reinterpret_cast<const nn::i64Tensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::f16Tensor: {
      auto ptr = reinterpret_cast<const nn::f16Tensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::f32Tensor: {
      auto ptr = reinterpret_cast<const nn::f32Tensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::f64Tensor: {
      auto ptr = reinterpret_cast<const nn::f64Tensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::CONV_2D: {
      auto ptr = reinterpret_cast<const nn::CONV_2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::AVERAGE_POOL_2D: {
      auto ptr = reinterpret_cast<const nn::AVERAGE_POOL_2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::MAX_POOL_2D: {
      auto ptr = reinterpret_cast<const nn::MAX_POOL_2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::RELU: {
      auto ptr = reinterpret_cast<const nn::RELU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::SOFTMAX: {
      auto ptr = reinterpret_cast<const nn::SOFTMAX *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::FULLY_CONNECTED: {
      auto ptr = reinterpret_cast<const nn::FULLY_CONNECTED *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::ADD: {
      auto ptr = reinterpret_cast<const nn::ADD *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::CONCATENATION: {
      auto ptr = reinterpret_cast<const nn::CONCATENATION *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::DEPTHWISE_CONV_2D: {
      auto ptr = reinterpret_cast<const nn::DEPTHWISE_CONV_2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::BATCH_TO_SPACE_ND: {
      auto ptr = reinterpret_cast<const nn::BATCH_TO_SPACE_ND *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::SPACE_TO_BATCH_ND: {
      auto ptr = reinterpret_cast<const nn::SPACE_TO_BATCH_ND *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::STRIDED_SLICE: {
      auto ptr = reinterpret_cast<const nn::STRIDED_SLICE *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::MUL: {
      auto ptr = reinterpret_cast<const nn::MUL *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::DEQUANTIZE: {
      auto ptr = reinterpret_cast<const nn::DEQUANTIZE *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::LOCAL_RESPONSE_NORMALIZATION: {
      auto ptr = reinterpret_cast<const nn::LOCAL_RESPONSE_NORMALIZATION *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::TANH: {
      auto ptr = reinterpret_cast<const nn::TANH *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::FLOOR: {
      auto ptr = reinterpret_cast<const nn::FLOOR *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::LOGISTIC: {
      auto ptr = reinterpret_cast<const nn::LOGISTIC *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::PRELU: {
      auto ptr = reinterpret_cast<const nn::PRELU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::POW: {
      auto ptr = reinterpret_cast<const nn::POW *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::NEG: {
      auto ptr = reinterpret_cast<const nn::NEG *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::MINIMUM: {
      auto ptr = reinterpret_cast<const nn::MINIMUM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::MAXIMUM: {
      auto ptr = reinterpret_cast<const nn::MAXIMUM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::LOG: {
      auto ptr = reinterpret_cast<const nn::LOG *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::ABS: {
      auto ptr = reinterpret_cast<const nn::ABS *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::EXP: {
      auto ptr = reinterpret_cast<const nn::EXP *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::SUB: {
      auto ptr = reinterpret_cast<const nn::SUB *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::GATHER: {
      auto ptr = reinterpret_cast<const nn::GATHER *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::RESHAPE: {
      auto ptr = reinterpret_cast<const nn::RESHAPE *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::Configure: {
      auto ptr = reinterpret_cast<const nn::Configure *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyLayerVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<Layer> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyLayer(
        verifier,  values->Get(i), types->GetEnum<Layer>(i))) {
      return false;
    }
  }
  return true;
}

inline const nn::Graph *GetGraph(const void *buf) {
  return flatbuffers::GetRoot<nn::Graph>(buf);
}

inline const nn::Graph *GetSizePrefixedGraph(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<nn::Graph>(buf);
}

inline bool VerifyGraphBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<nn::Graph>(nullptr);
}

inline bool VerifySizePrefixedGraphBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<nn::Graph>(nullptr);
}

inline void FinishGraphBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<nn::Graph> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedGraphBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<nn::Graph> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace nn

#endif  // FLATBUFFERS_GENERATED_GNT_NN_H_
