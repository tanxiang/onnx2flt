// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GNT_NN_H_
#define FLATBUFFERS_GENERATED_GNT_NN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 22 &&
              FLATBUFFERS_VERSION_MINOR == 11 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace nn {

struct versionInfo;

struct TensorInfo;
struct TensorInfoBuilder;

struct RawTensor;
struct RawTensorBuilder;

struct I32Scalar;

struct U32Scalar;

struct F32Scalar;

struct I32Tensor;
struct I32TensorBuilder;

struct U32Tensor;
struct U32TensorBuilder;

struct F16Tensor;
struct F16TensorBuilder;

struct F32Tensor;
struct F32TensorBuilder;

struct F64Tensor;
struct F64TensorBuilder;

struct QuantInfo;
struct QuantInfoBuilder;

struct DimValue;

struct DimParam;
struct DimParamBuilder;

struct TensorShape;
struct TensorShapeBuilder;

struct InputTensor;
struct InputTensorBuilder;

struct LinkOd;
struct LinkOdBuilder;

struct Link;
struct LinkBuilder;

struct Pads;

struct Stride;

struct Dilation;

struct KernelShape;

struct Group;

struct CONV_2D;
struct CONV_2DBuilder;

struct AVERAGE_POOL_2D;
struct AVERAGE_POOL_2DBuilder;

struct MAX_POOL_2D;
struct MAX_POOL_2DBuilder;

struct RELU;
struct RELUBuilder;

struct SOFTMAX;
struct SOFTMAXBuilder;

struct FULLY_CONNECTED;
struct FULLY_CONNECTEDBuilder;

struct ADD;
struct ADDBuilder;

struct SUB;
struct SUBBuilder;

struct MUL;
struct MULBuilder;

struct CONCATENATION;
struct CONCATENATIONBuilder;

struct DEPTHWISE_CONV_2D;
struct DEPTHWISE_CONV_2DBuilder;

struct BATCH_TO_SPACE_ND;
struct BATCH_TO_SPACE_NDBuilder;

struct SPACE_TO_BATCH_ND;
struct SPACE_TO_BATCH_NDBuilder;

struct STRIDED_SLICE;
struct STRIDED_SLICEBuilder;

struct DEQUANTIZE;
struct DEQUANTIZEBuilder;

struct LOCAL_RESPONSE_NORMALIZATION;
struct LOCAL_RESPONSE_NORMALIZATIONBuilder;

struct TANH;
struct TANHBuilder;

struct FLOOR;
struct FLOORBuilder;

struct LOGISTIC;
struct LOGISTICBuilder;

struct PRELU;
struct PRELUBuilder;

struct POW;
struct POWBuilder;

struct NEG;
struct NEGBuilder;

struct MINIMUM;
struct MINIMUMBuilder;

struct MAXIMUM;
struct MAXIMUMBuilder;

struct LOG;
struct LOGBuilder;

struct ABS;
struct ABSBuilder;

struct EXP;
struct EXPBuilder;

struct GATHER;
struct GATHERBuilder;

struct RESHAPE;
struct RESHAPEBuilder;

struct Configure;
struct ConfigureBuilder;

struct FuseNode;

struct Output;
struct OutputBuilder;

struct Graph;
struct GraphBuilder;

enum class DataType : int8_t {
  Float16 = 0,
  Float32 = 1,
  Float64 = 2,
  Int8 = 3,
  Int16 = 4,
  Int32 = 5,
  Int64 = 6,
  QuantAsymm = 7,
  QuantSymm = 8,
  QuantSymmPerChannel = 9,
  Unknown = 10,
  MIN = Float16,
  MAX = Unknown
};

inline const DataType (&EnumValuesDataType())[11] {
  static const DataType values[] = {
    DataType::Float16,
    DataType::Float32,
    DataType::Float64,
    DataType::Int8,
    DataType::Int16,
    DataType::Int32,
    DataType::Int64,
    DataType::QuantAsymm,
    DataType::QuantSymm,
    DataType::QuantSymmPerChannel,
    DataType::Unknown
  };
  return values;
}

inline const char * const *EnumNamesDataType() {
  static const char * const names[12] = {
    "Float16",
    "Float32",
    "Float64",
    "Int8",
    "Int16",
    "Int32",
    "Int64",
    "QuantAsymm",
    "QuantSymm",
    "QuantSymmPerChannel",
    "Unknown",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataType(DataType e) {
  if (flatbuffers::IsOutRange(e, DataType::Float16, DataType::Unknown)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataType()[index];
}

enum class FuseCode : int8_t {
  None = 0,
  Relu = 1,
  Relu1 = 2,
  Relu6 = 3,
  MIN = None,
  MAX = Relu6
};

inline const FuseCode (&EnumValuesFuseCode())[4] {
  static const FuseCode values[] = {
    FuseCode::None,
    FuseCode::Relu,
    FuseCode::Relu1,
    FuseCode::Relu6
  };
  return values;
}

inline const char * const *EnumNamesFuseCode() {
  static const char * const names[5] = {
    "None",
    "Relu",
    "Relu1",
    "Relu6",
    nullptr
  };
  return names;
}

inline const char *EnumNameFuseCode(FuseCode e) {
  if (flatbuffers::IsOutRange(e, FuseCode::None, FuseCode::Relu6)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFuseCode()[index];
}

enum class Dim : uint8_t {
  NONE = 0,
  DimValue = 1,
  DimParam = 2,
  MIN = NONE,
  MAX = DimParam
};

inline const Dim (&EnumValuesDim())[3] {
  static const Dim values[] = {
    Dim::NONE,
    Dim::DimValue,
    Dim::DimParam
  };
  return values;
}

inline const char * const *EnumNamesDim() {
  static const char * const names[4] = {
    "NONE",
    "DimValue",
    "DimParam",
    nullptr
  };
  return names;
}

inline const char *EnumNameDim(Dim e) {
  if (flatbuffers::IsOutRange(e, Dim::NONE, Dim::DimParam)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDim()[index];
}

template<typename T> struct DimTraits {
  static const Dim enum_value = Dim::NONE;
};

template<> struct DimTraits<nn::DimValue> {
  static const Dim enum_value = Dim::DimValue;
};

template<> struct DimTraits<nn::DimParam> {
  static const Dim enum_value = Dim::DimParam;
};

bool VerifyDim(flatbuffers::Verifier &verifier, const void *obj, Dim type);
bool VerifyDimVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<Dim> *types);

enum class Layer : uint8_t {
  NONE = 0,
  InputTensor = 1,
  RawTensor = 2,
  I32Scalar = 3,
  U32Scalar = 4,
  FuseNode = 5,
  I32Tensor = 6,
  U32Tensor = 7,
  F16Tensor = 8,
  F32Tensor = 9,
  F64Tensor = 10,
  CONV_2D = 11,
  AVERAGE_POOL_2D = 12,
  MAX_POOL_2D = 13,
  RELU = 14,
  SOFTMAX = 15,
  FULLY_CONNECTED = 16,
  ADD = 17,
  CONCATENATION = 18,
  DEPTHWISE_CONV_2D = 19,
  BATCH_TO_SPACE_ND = 20,
  SPACE_TO_BATCH_ND = 21,
  STRIDED_SLICE = 22,
  MUL = 23,
  DEQUANTIZE = 24,
  LOCAL_RESPONSE_NORMALIZATION = 25,
  TANH = 26,
  FLOOR = 27,
  LOGISTIC = 28,
  PRELU = 29,
  POW = 30,
  NEG = 31,
  MINIMUM = 32,
  MAXIMUM = 33,
  LOG = 34,
  ABS = 35,
  EXP = 36,
  SUB = 37,
  GATHER = 38,
  RESHAPE = 39,
  Configure = 40,
  MIN = NONE,
  MAX = Configure
};

inline const Layer (&EnumValuesLayer())[41] {
  static const Layer values[] = {
    Layer::NONE,
    Layer::InputTensor,
    Layer::RawTensor,
    Layer::I32Scalar,
    Layer::U32Scalar,
    Layer::FuseNode,
    Layer::I32Tensor,
    Layer::U32Tensor,
    Layer::F16Tensor,
    Layer::F32Tensor,
    Layer::F64Tensor,
    Layer::CONV_2D,
    Layer::AVERAGE_POOL_2D,
    Layer::MAX_POOL_2D,
    Layer::RELU,
    Layer::SOFTMAX,
    Layer::FULLY_CONNECTED,
    Layer::ADD,
    Layer::CONCATENATION,
    Layer::DEPTHWISE_CONV_2D,
    Layer::BATCH_TO_SPACE_ND,
    Layer::SPACE_TO_BATCH_ND,
    Layer::STRIDED_SLICE,
    Layer::MUL,
    Layer::DEQUANTIZE,
    Layer::LOCAL_RESPONSE_NORMALIZATION,
    Layer::TANH,
    Layer::FLOOR,
    Layer::LOGISTIC,
    Layer::PRELU,
    Layer::POW,
    Layer::NEG,
    Layer::MINIMUM,
    Layer::MAXIMUM,
    Layer::LOG,
    Layer::ABS,
    Layer::EXP,
    Layer::SUB,
    Layer::GATHER,
    Layer::RESHAPE,
    Layer::Configure
  };
  return values;
}

inline const char * const *EnumNamesLayer() {
  static const char * const names[42] = {
    "NONE",
    "InputTensor",
    "RawTensor",
    "I32Scalar",
    "U32Scalar",
    "FuseNode",
    "I32Tensor",
    "U32Tensor",
    "F16Tensor",
    "F32Tensor",
    "F64Tensor",
    "CONV_2D",
    "AVERAGE_POOL_2D",
    "MAX_POOL_2D",
    "RELU",
    "SOFTMAX",
    "FULLY_CONNECTED",
    "ADD",
    "CONCATENATION",
    "DEPTHWISE_CONV_2D",
    "BATCH_TO_SPACE_ND",
    "SPACE_TO_BATCH_ND",
    "STRIDED_SLICE",
    "MUL",
    "DEQUANTIZE",
    "LOCAL_RESPONSE_NORMALIZATION",
    "TANH",
    "FLOOR",
    "LOGISTIC",
    "PRELU",
    "POW",
    "NEG",
    "MINIMUM",
    "MAXIMUM",
    "LOG",
    "ABS",
    "EXP",
    "SUB",
    "GATHER",
    "RESHAPE",
    "Configure",
    nullptr
  };
  return names;
}

inline const char *EnumNameLayer(Layer e) {
  if (flatbuffers::IsOutRange(e, Layer::NONE, Layer::Configure)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLayer()[index];
}

template<typename T> struct LayerTraits {
  static const Layer enum_value = Layer::NONE;
};

template<> struct LayerTraits<nn::InputTensor> {
  static const Layer enum_value = Layer::InputTensor;
};

template<> struct LayerTraits<nn::RawTensor> {
  static const Layer enum_value = Layer::RawTensor;
};

template<> struct LayerTraits<nn::I32Scalar> {
  static const Layer enum_value = Layer::I32Scalar;
};

template<> struct LayerTraits<nn::U32Scalar> {
  static const Layer enum_value = Layer::U32Scalar;
};

template<> struct LayerTraits<nn::FuseNode> {
  static const Layer enum_value = Layer::FuseNode;
};

template<> struct LayerTraits<nn::I32Tensor> {
  static const Layer enum_value = Layer::I32Tensor;
};

template<> struct LayerTraits<nn::U32Tensor> {
  static const Layer enum_value = Layer::U32Tensor;
};

template<> struct LayerTraits<nn::F16Tensor> {
  static const Layer enum_value = Layer::F16Tensor;
};

template<> struct LayerTraits<nn::F32Tensor> {
  static const Layer enum_value = Layer::F32Tensor;
};

template<> struct LayerTraits<nn::F64Tensor> {
  static const Layer enum_value = Layer::F64Tensor;
};

template<> struct LayerTraits<nn::CONV_2D> {
  static const Layer enum_value = Layer::CONV_2D;
};

template<> struct LayerTraits<nn::AVERAGE_POOL_2D> {
  static const Layer enum_value = Layer::AVERAGE_POOL_2D;
};

template<> struct LayerTraits<nn::MAX_POOL_2D> {
  static const Layer enum_value = Layer::MAX_POOL_2D;
};

template<> struct LayerTraits<nn::RELU> {
  static const Layer enum_value = Layer::RELU;
};

template<> struct LayerTraits<nn::SOFTMAX> {
  static const Layer enum_value = Layer::SOFTMAX;
};

template<> struct LayerTraits<nn::FULLY_CONNECTED> {
  static const Layer enum_value = Layer::FULLY_CONNECTED;
};

template<> struct LayerTraits<nn::ADD> {
  static const Layer enum_value = Layer::ADD;
};

template<> struct LayerTraits<nn::CONCATENATION> {
  static const Layer enum_value = Layer::CONCATENATION;
};

template<> struct LayerTraits<nn::DEPTHWISE_CONV_2D> {
  static const Layer enum_value = Layer::DEPTHWISE_CONV_2D;
};

template<> struct LayerTraits<nn::BATCH_TO_SPACE_ND> {
  static const Layer enum_value = Layer::BATCH_TO_SPACE_ND;
};

template<> struct LayerTraits<nn::SPACE_TO_BATCH_ND> {
  static const Layer enum_value = Layer::SPACE_TO_BATCH_ND;
};

template<> struct LayerTraits<nn::STRIDED_SLICE> {
  static const Layer enum_value = Layer::STRIDED_SLICE;
};

template<> struct LayerTraits<nn::MUL> {
  static const Layer enum_value = Layer::MUL;
};

template<> struct LayerTraits<nn::DEQUANTIZE> {
  static const Layer enum_value = Layer::DEQUANTIZE;
};

template<> struct LayerTraits<nn::LOCAL_RESPONSE_NORMALIZATION> {
  static const Layer enum_value = Layer::LOCAL_RESPONSE_NORMALIZATION;
};

template<> struct LayerTraits<nn::TANH> {
  static const Layer enum_value = Layer::TANH;
};

template<> struct LayerTraits<nn::FLOOR> {
  static const Layer enum_value = Layer::FLOOR;
};

template<> struct LayerTraits<nn::LOGISTIC> {
  static const Layer enum_value = Layer::LOGISTIC;
};

template<> struct LayerTraits<nn::PRELU> {
  static const Layer enum_value = Layer::PRELU;
};

template<> struct LayerTraits<nn::POW> {
  static const Layer enum_value = Layer::POW;
};

template<> struct LayerTraits<nn::NEG> {
  static const Layer enum_value = Layer::NEG;
};

template<> struct LayerTraits<nn::MINIMUM> {
  static const Layer enum_value = Layer::MINIMUM;
};

template<> struct LayerTraits<nn::MAXIMUM> {
  static const Layer enum_value = Layer::MAXIMUM;
};

template<> struct LayerTraits<nn::LOG> {
  static const Layer enum_value = Layer::LOG;
};

template<> struct LayerTraits<nn::ABS> {
  static const Layer enum_value = Layer::ABS;
};

template<> struct LayerTraits<nn::EXP> {
  static const Layer enum_value = Layer::EXP;
};

template<> struct LayerTraits<nn::SUB> {
  static const Layer enum_value = Layer::SUB;
};

template<> struct LayerTraits<nn::GATHER> {
  static const Layer enum_value = Layer::GATHER;
};

template<> struct LayerTraits<nn::RESHAPE> {
  static const Layer enum_value = Layer::RESHAPE;
};

template<> struct LayerTraits<nn::Configure> {
  static const Layer enum_value = Layer::Configure;
};

bool VerifyLayer(flatbuffers::Verifier &verifier, const void *obj, Layer type);
bool VerifyLayerVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<Layer> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) versionInfo FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t codeversion_;
  int64_t dataversion_;

 public:
  struct Traits;
  versionInfo()
      : codeversion_(0),
        dataversion_(0) {
  }
  versionInfo(uint64_t _codeversion, int64_t _dataversion)
      : codeversion_(flatbuffers::EndianScalar(_codeversion)),
        dataversion_(flatbuffers::EndianScalar(_dataversion)) {
  }
  uint64_t codeversion() const {
    return flatbuffers::EndianScalar(codeversion_);
  }
  int64_t dataversion() const {
    return flatbuffers::EndianScalar(dataversion_);
  }
};
FLATBUFFERS_STRUCT_END(versionInfo, 16);

struct versionInfo::Traits {
  using type = versionInfo;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) I32Scalar FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t data_;

 public:
  struct Traits;
  I32Scalar()
      : data_(0) {
  }
  I32Scalar(int32_t _data)
      : data_(flatbuffers::EndianScalar(_data)) {
  }
  int32_t data() const {
    return flatbuffers::EndianScalar(data_);
  }
};
FLATBUFFERS_STRUCT_END(I32Scalar, 4);

struct I32Scalar::Traits {
  using type = I32Scalar;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) U32Scalar FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t data_;

 public:
  struct Traits;
  U32Scalar()
      : data_(0) {
  }
  U32Scalar(uint32_t _data)
      : data_(flatbuffers::EndianScalar(_data)) {
  }
  uint32_t data() const {
    return flatbuffers::EndianScalar(data_);
  }
};
FLATBUFFERS_STRUCT_END(U32Scalar, 4);

struct U32Scalar::Traits {
  using type = U32Scalar;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) F32Scalar FLATBUFFERS_FINAL_CLASS {
 private:
  float data_;

 public:
  struct Traits;
  F32Scalar()
      : data_(0) {
  }
  F32Scalar(float _data)
      : data_(flatbuffers::EndianScalar(_data)) {
  }
  float data() const {
    return flatbuffers::EndianScalar(data_);
  }
};
FLATBUFFERS_STRUCT_END(F32Scalar, 4);

struct F32Scalar::Traits {
  using type = F32Scalar;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) DimValue FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t val_;

 public:
  struct Traits;
  DimValue()
      : val_(0) {
  }
  DimValue(int32_t _val)
      : val_(flatbuffers::EndianScalar(_val)) {
  }
  int32_t val() const {
    return flatbuffers::EndianScalar(val_);
  }
};
FLATBUFFERS_STRUCT_END(DimValue, 4);

struct DimValue::Traits {
  using type = DimValue;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Pads FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t left_;
  int32_t right_;
  int32_t top_;
  int32_t bottom_;

 public:
  struct Traits;
  Pads()
      : left_(0),
        right_(0),
        top_(0),
        bottom_(0) {
  }
  Pads(int32_t _left, int32_t _right, int32_t _top, int32_t _bottom)
      : left_(flatbuffers::EndianScalar(_left)),
        right_(flatbuffers::EndianScalar(_right)),
        top_(flatbuffers::EndianScalar(_top)),
        bottom_(flatbuffers::EndianScalar(_bottom)) {
  }
  int32_t left() const {
    return flatbuffers::EndianScalar(left_);
  }
  int32_t right() const {
    return flatbuffers::EndianScalar(right_);
  }
  int32_t top() const {
    return flatbuffers::EndianScalar(top_);
  }
  int32_t bottom() const {
    return flatbuffers::EndianScalar(bottom_);
  }
};
FLATBUFFERS_STRUCT_END(Pads, 16);

struct Pads::Traits {
  using type = Pads;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Stride FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;

 public:
  struct Traits;
  Stride()
      : x_(0),
        y_(0) {
  }
  Stride(int32_t _x, int32_t _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Stride, 8);

struct Stride::Traits {
  using type = Stride;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Dilation FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;

 public:
  struct Traits;
  Dilation()
      : x_(0),
        y_(0) {
  }
  Dilation(int32_t _x, int32_t _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Dilation, 8);

struct Dilation::Traits {
  using type = Dilation;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) KernelShape FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t width_;
  int32_t height_;

 public:
  struct Traits;
  KernelShape()
      : width_(0),
        height_(0) {
  }
  KernelShape(int32_t _width, int32_t _height)
      : width_(flatbuffers::EndianScalar(_width)),
        height_(flatbuffers::EndianScalar(_height)) {
  }
  int32_t width() const {
    return flatbuffers::EndianScalar(width_);
  }
  int32_t height() const {
    return flatbuffers::EndianScalar(height_);
  }
};
FLATBUFFERS_STRUCT_END(KernelShape, 8);

struct KernelShape::Traits {
  using type = KernelShape;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Group FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t id_;

 public:
  struct Traits;
  Group()
      : id_(0) {
  }
  Group(int32_t _id)
      : id_(flatbuffers::EndianScalar(_id)) {
  }
  int32_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
};
FLATBUFFERS_STRUCT_END(Group, 4);

struct Group::Traits {
  using type = Group;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) FuseNode FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t code_;

 public:
  struct Traits;
  FuseNode()
      : code_(0) {
  }
  FuseNode(nn::FuseCode _code)
      : code_(flatbuffers::EndianScalar(static_cast<int8_t>(_code))) {
  }
  nn::FuseCode code() const {
    return static_cast<nn::FuseCode>(flatbuffers::EndianScalar(code_));
  }
};
FLATBUFFERS_STRUCT_END(FuseNode, 1);

struct FuseNode::Traits {
  using type = FuseNode;
};

struct TensorInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DIM = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<uint16_t> *dim() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_DIM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DIM) &&
           verifier.VerifyVector(dim()) &&
           verifier.EndTable();
  }
};

struct TensorInfoBuilder {
  typedef TensorInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TensorInfo::VT_NAME, name);
  }
  void add_dim(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> dim) {
    fbb_.AddOffset(TensorInfo::VT_DIM, dim);
  }
  explicit TensorInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorInfo> CreateTensorInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> dim = 0) {
  TensorInfoBuilder builder_(_fbb);
  builder_.add_dim(dim);
  builder_.add_name(name);
  return builder_.Finish();
}

struct TensorInfo::Traits {
  using type = TensorInfo;
  static auto constexpr Create = CreateTensorInfo;
};

inline flatbuffers::Offset<TensorInfo> CreateTensorInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<uint16_t> *dim = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto dim__ = dim ? _fbb.CreateVector<uint16_t>(*dim) : 0;
  return nn::CreateTensorInfo(
      _fbb,
      name__,
      dim__);
}

struct RawTensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RawTensorBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4,
    VT_TYPE = 6,
    VT_DATA = 8
  };
  const nn::TensorInfo *info() const {
    return GetPointer<const nn::TensorInfo *>(VT_INFO);
  }
  nn::DataType type() const {
    return static_cast<nn::DataType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::String *data() const {
    return GetPointer<const flatbuffers::String *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyString(data()) &&
           verifier.EndTable();
  }
};

struct RawTensorBuilder {
  typedef RawTensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<nn::TensorInfo> info) {
    fbb_.AddOffset(RawTensor::VT_INFO, info);
  }
  void add_type(nn::DataType type) {
    fbb_.AddElement<int8_t>(RawTensor::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::String> data) {
    fbb_.AddOffset(RawTensor::VT_DATA, data);
  }
  explicit RawTensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RawTensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RawTensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<RawTensor> CreateRawTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    nn::DataType type = nn::DataType::Float16,
    flatbuffers::Offset<flatbuffers::String> data = 0) {
  RawTensorBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_info(info);
  builder_.add_type(type);
  return builder_.Finish();
}

struct RawTensor::Traits {
  using type = RawTensor;
  static auto constexpr Create = CreateRawTensor;
};

inline flatbuffers::Offset<RawTensor> CreateRawTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    nn::DataType type = nn::DataType::Float16,
    const char *data = nullptr) {
  auto data__ = data ? _fbb.CreateString(data) : 0;
  return nn::CreateRawTensor(
      _fbb,
      info,
      type,
      data__);
}

struct I32Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef I32TensorBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4,
    VT_DATA = 6
  };
  const nn::TensorInfo *info() const {
    return GetPointer<const nn::TensorInfo *>(VT_INFO);
  }
  const flatbuffers::Vector<int32_t> *data() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct I32TensorBuilder {
  typedef I32Tensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<nn::TensorInfo> info) {
    fbb_.AddOffset(I32Tensor::VT_INFO, info);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<int32_t>> data) {
    fbb_.AddOffset(I32Tensor::VT_DATA, data);
  }
  explicit I32TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<I32Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<I32Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<I32Tensor> CreateI32Tensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> data = 0) {
  I32TensorBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_info(info);
  return builder_.Finish();
}

struct I32Tensor::Traits {
  using type = I32Tensor;
  static auto constexpr Create = CreateI32Tensor;
};

inline flatbuffers::Offset<I32Tensor> CreateI32TensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    const std::vector<int32_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<int32_t>(*data) : 0;
  return nn::CreateI32Tensor(
      _fbb,
      info,
      data__);
}

struct U32Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef U32TensorBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4,
    VT_DATA = 6
  };
  const nn::TensorInfo *info() const {
    return GetPointer<const nn::TensorInfo *>(VT_INFO);
  }
  const flatbuffers::Vector<uint32_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct U32TensorBuilder {
  typedef U32Tensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<nn::TensorInfo> info) {
    fbb_.AddOffset(U32Tensor::VT_INFO, info);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data) {
    fbb_.AddOffset(U32Tensor::VT_DATA, data);
  }
  explicit U32TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<U32Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<U32Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<U32Tensor> CreateU32Tensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data = 0) {
  U32TensorBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_info(info);
  return builder_.Finish();
}

struct U32Tensor::Traits {
  using type = U32Tensor;
  static auto constexpr Create = CreateU32Tensor;
};

inline flatbuffers::Offset<U32Tensor> CreateU32TensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    const std::vector<uint32_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint32_t>(*data) : 0;
  return nn::CreateU32Tensor(
      _fbb,
      info,
      data__);
}

struct F16Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef F16TensorBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4,
    VT_DATA = 6
  };
  const nn::TensorInfo *info() const {
    return GetPointer<const nn::TensorInfo *>(VT_INFO);
  }
  const flatbuffers::Vector<uint16_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct F16TensorBuilder {
  typedef F16Tensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<nn::TensorInfo> info) {
    fbb_.AddOffset(F16Tensor::VT_INFO, info);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> data) {
    fbb_.AddOffset(F16Tensor::VT_DATA, data);
  }
  explicit F16TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<F16Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<F16Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<F16Tensor> CreateF16Tensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> data = 0) {
  F16TensorBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_info(info);
  return builder_.Finish();
}

struct F16Tensor::Traits {
  using type = F16Tensor;
  static auto constexpr Create = CreateF16Tensor;
};

inline flatbuffers::Offset<F16Tensor> CreateF16TensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    const std::vector<uint16_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint16_t>(*data) : 0;
  return nn::CreateF16Tensor(
      _fbb,
      info,
      data__);
}

struct F32Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef F32TensorBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4,
    VT_DATA = 6
  };
  const nn::TensorInfo *info() const {
    return GetPointer<const nn::TensorInfo *>(VT_INFO);
  }
  const flatbuffers::Vector<float> *data() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct F32TensorBuilder {
  typedef F32Tensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<nn::TensorInfo> info) {
    fbb_.AddOffset(F32Tensor::VT_INFO, info);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<float>> data) {
    fbb_.AddOffset(F32Tensor::VT_DATA, data);
  }
  explicit F32TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<F32Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<F32Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<F32Tensor> CreateF32Tensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> data = 0) {
  F32TensorBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_info(info);
  return builder_.Finish();
}

struct F32Tensor::Traits {
  using type = F32Tensor;
  static auto constexpr Create = CreateF32Tensor;
};

inline flatbuffers::Offset<F32Tensor> CreateF32TensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    const std::vector<float> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<float>(*data) : 0;
  return nn::CreateF32Tensor(
      _fbb,
      info,
      data__);
}

struct F64Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef F64TensorBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4,
    VT_DATA = 6
  };
  const nn::TensorInfo *info() const {
    return GetPointer<const nn::TensorInfo *>(VT_INFO);
  }
  const flatbuffers::Vector<double> *data() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct F64TensorBuilder {
  typedef F64Tensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<nn::TensorInfo> info) {
    fbb_.AddOffset(F64Tensor::VT_INFO, info);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<double>> data) {
    fbb_.AddOffset(F64Tensor::VT_DATA, data);
  }
  explicit F64TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<F64Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<F64Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<F64Tensor> CreateF64Tensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> data = 0) {
  F64TensorBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_info(info);
  return builder_.Finish();
}

struct F64Tensor::Traits {
  using type = F64Tensor;
  static auto constexpr Create = CreateF64Tensor;
};

inline flatbuffers::Offset<F64Tensor> CreateF64TensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    const std::vector<double> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<double>(*data) : 0;
  return nn::CreateF64Tensor(
      _fbb,
      info,
      data__);
}

struct QuantInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuantInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_DIM = 8,
    VT_SCALES = 10,
    VT_ZERO_POINT = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  nn::DataType type() const {
    return static_cast<nn::DataType>(GetField<int8_t>(VT_TYPE, 0));
  }
  uint16_t dim() const {
    return GetField<uint16_t>(VT_DIM, 0);
  }
  const flatbuffers::Vector<float> *scales() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALES);
  }
  int32_t zero_point() const {
    return GetField<int32_t>(VT_ZERO_POINT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint16_t>(verifier, VT_DIM, 2) &&
           VerifyOffset(verifier, VT_SCALES) &&
           verifier.VerifyVector(scales()) &&
           VerifyField<int32_t>(verifier, VT_ZERO_POINT, 4) &&
           verifier.EndTable();
  }
};

struct QuantInfoBuilder {
  typedef QuantInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(QuantInfo::VT_NAME, name);
  }
  void add_type(nn::DataType type) {
    fbb_.AddElement<int8_t>(QuantInfo::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_dim(uint16_t dim) {
    fbb_.AddElement<uint16_t>(QuantInfo::VT_DIM, dim, 0);
  }
  void add_scales(flatbuffers::Offset<flatbuffers::Vector<float>> scales) {
    fbb_.AddOffset(QuantInfo::VT_SCALES, scales);
  }
  void add_zero_point(int32_t zero_point) {
    fbb_.AddElement<int32_t>(QuantInfo::VT_ZERO_POINT, zero_point, 0);
  }
  explicit QuantInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<QuantInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantInfo>(end);
    fbb_.Required(o, QuantInfo::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<QuantInfo> CreateQuantInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    nn::DataType type = nn::DataType::Float16,
    uint16_t dim = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scales = 0,
    int32_t zero_point = 0) {
  QuantInfoBuilder builder_(_fbb);
  builder_.add_zero_point(zero_point);
  builder_.add_scales(scales);
  builder_.add_name(name);
  builder_.add_dim(dim);
  builder_.add_type(type);
  return builder_.Finish();
}

struct QuantInfo::Traits {
  using type = QuantInfo;
  static auto constexpr Create = CreateQuantInfo;
};

inline flatbuffers::Offset<QuantInfo> CreateQuantInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    nn::DataType type = nn::DataType::Float16,
    uint16_t dim = 0,
    const std::vector<float> *scales = nullptr,
    int32_t zero_point = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto scales__ = scales ? _fbb.CreateVector<float>(*scales) : 0;
  return nn::CreateQuantInfo(
      _fbb,
      name__,
      type,
      dim,
      scales__,
      zero_point);
}

struct DimParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DimParamBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct DimParamBuilder {
  typedef DimParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(DimParam::VT_NAME, name);
  }
  explicit DimParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DimParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DimParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<DimParam> CreateDimParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  DimParamBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

struct DimParam::Traits {
  using type = DimParam;
  static auto constexpr Create = CreateDimParam;
};

inline flatbuffers::Offset<DimParam> CreateDimParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return nn::CreateDimParam(
      _fbb,
      name__);
}

struct TensorShape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorShapeBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_DIMS_TYPE = 6,
    VT_DIMS = 8
  };
  nn::DataType type() const {
    return static_cast<nn::DataType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<nn::Dim> *dims_type() const {
    return GetPointer<const flatbuffers::Vector<nn::Dim> *>(VT_DIMS_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *dims() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_DIMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_DIMS_TYPE) &&
           verifier.VerifyVector(dims_type()) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           VerifyDimVector(verifier, dims(), dims_type()) &&
           verifier.EndTable();
  }
};

struct TensorShapeBuilder {
  typedef TensorShape Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(nn::DataType type) {
    fbb_.AddElement<int8_t>(TensorShape::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_dims_type(flatbuffers::Offset<flatbuffers::Vector<nn::Dim>> dims_type) {
    fbb_.AddOffset(TensorShape::VT_DIMS_TYPE, dims_type);
  }
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> dims) {
    fbb_.AddOffset(TensorShape::VT_DIMS, dims);
  }
  explicit TensorShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorShape>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorShape> CreateTensorShape(
    flatbuffers::FlatBufferBuilder &_fbb,
    nn::DataType type = nn::DataType::Float16,
    flatbuffers::Offset<flatbuffers::Vector<nn::Dim>> dims_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> dims = 0) {
  TensorShapeBuilder builder_(_fbb);
  builder_.add_dims(dims);
  builder_.add_dims_type(dims_type);
  builder_.add_type(type);
  return builder_.Finish();
}

struct TensorShape::Traits {
  using type = TensorShape;
  static auto constexpr Create = CreateTensorShape;
};

inline flatbuffers::Offset<TensorShape> CreateTensorShapeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    nn::DataType type = nn::DataType::Float16,
    const std::vector<nn::Dim> *dims_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *dims = nullptr) {
  auto dims_type__ = dims_type ? _fbb.CreateVector<nn::Dim>(*dims_type) : 0;
  auto dims__ = dims ? _fbb.CreateVector<flatbuffers::Offset<void>>(*dims) : 0;
  return nn::CreateTensorShape(
      _fbb,
      type,
      dims_type__,
      dims__);
}

struct InputTensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InputTensorBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE = 4
  };
  const nn::TensorShape *shape() const {
    return GetPointer<const nn::TensorShape *>(VT_SHAPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyTable(shape()) &&
           verifier.EndTable();
  }
};

struct InputTensorBuilder {
  typedef InputTensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shape(flatbuffers::Offset<nn::TensorShape> shape) {
    fbb_.AddOffset(InputTensor::VT_SHAPE, shape);
  }
  explicit InputTensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InputTensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InputTensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<InputTensor> CreateInputTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorShape> shape = 0) {
  InputTensorBuilder builder_(_fbb);
  builder_.add_shape(shape);
  return builder_.Finish();
}

struct InputTensor::Traits {
  using type = InputTensor;
  static auto constexpr Create = CreateInputTensor;
};

struct LinkOd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LinkOdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_OUTPUT = 6,
    VT_NAME = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *input() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_INPUT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *output() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_OUTPUT);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_INPUT) &&
           verifier.VerifyVector(input()) &&
           verifier.VerifyVectorOfStrings(input()) &&
           VerifyOffsetRequired(verifier, VT_OUTPUT) &&
           verifier.VerifyVector(output()) &&
           verifier.VerifyVectorOfStrings(output()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct LinkOdBuilder {
  typedef LinkOd Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> input) {
    fbb_.AddOffset(LinkOd::VT_INPUT, input);
  }
  void add_output(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> output) {
    fbb_.AddOffset(LinkOd::VT_OUTPUT, output);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(LinkOd::VT_NAME, name);
  }
  explicit LinkOdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LinkOd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LinkOd>(end);
    fbb_.Required(o, LinkOd::VT_INPUT);
    fbb_.Required(o, LinkOd::VT_OUTPUT);
    return o;
  }
};

inline flatbuffers::Offset<LinkOd> CreateLinkOd(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> input = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> output = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  LinkOdBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_output(output);
  builder_.add_input(input);
  return builder_.Finish();
}

struct LinkOd::Traits {
  using type = LinkOd;
  static auto constexpr Create = CreateLinkOd;
};

inline flatbuffers::Offset<LinkOd> CreateLinkOdDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *input = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *output = nullptr,
    const char *name = nullptr) {
  auto input__ = input ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*input) : 0;
  auto output__ = output ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*output) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return nn::CreateLinkOd(
      _fbb,
      input__,
      output__,
      name__);
}

struct Link FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LinkBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_EXT_OUTPUT = 6,
    VT_NAME = 8
  };
  const flatbuffers::Vector<int32_t> *input() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUT);
  }
  const flatbuffers::Vector<uint32_t> *ext_output() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_EXT_OUTPUT);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_INPUT) &&
           verifier.VerifyVector(input()) &&
           VerifyOffset(verifier, VT_EXT_OUTPUT) &&
           verifier.VerifyVector(ext_output()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct LinkBuilder {
  typedef Link Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::Vector<int32_t>> input) {
    fbb_.AddOffset(Link::VT_INPUT, input);
  }
  void add_ext_output(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> ext_output) {
    fbb_.AddOffset(Link::VT_EXT_OUTPUT, ext_output);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Link::VT_NAME, name);
  }
  explicit LinkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Link> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Link>(end);
    fbb_.Required(o, Link::VT_INPUT);
    return o;
  }
};

inline flatbuffers::Offset<Link> CreateLink(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> input = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> ext_output = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  LinkBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_ext_output(ext_output);
  builder_.add_input(input);
  return builder_.Finish();
}

struct Link::Traits {
  using type = Link;
  static auto constexpr Create = CreateLink;
};

inline flatbuffers::Offset<Link> CreateLinkDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *input = nullptr,
    const std::vector<uint32_t> *ext_output = nullptr,
    const char *name = nullptr) {
  auto input__ = input ? _fbb.CreateVector<int32_t>(*input) : 0;
  auto ext_output__ = ext_output ? _fbb.CreateVector<uint32_t>(*ext_output) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return nn::CreateLink(
      _fbb,
      input__,
      ext_output__,
      name__);
}

struct CONV_2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CONV_2DBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_FUSE_NODE = 6,
    VT_PADDING = 8,
    VT_STRIDE = 10,
    VT_DILATION = 12,
    VT_GROUP = 14
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  int32_t fuse_node() const {
    return GetField<int32_t>(VT_FUSE_NODE, 0);
  }
  const nn::Pads *padding() const {
    return GetStruct<const nn::Pads *>(VT_PADDING);
  }
  const nn::Stride *stride() const {
    return GetStruct<const nn::Stride *>(VT_STRIDE);
  }
  const nn::Dilation *dilation() const {
    return GetStruct<const nn::Dilation *>(VT_DILATION);
  }
  const nn::Group *group() const {
    return GetStruct<const nn::Group *>(VT_GROUP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<int32_t>(verifier, VT_FUSE_NODE, 4) &&
           VerifyField<nn::Pads>(verifier, VT_PADDING, 4) &&
           VerifyField<nn::Stride>(verifier, VT_STRIDE, 4) &&
           VerifyField<nn::Dilation>(verifier, VT_DILATION, 4) &&
           VerifyField<nn::Group>(verifier, VT_GROUP, 4) &&
           verifier.EndTable();
  }
};

struct CONV_2DBuilder {
  typedef CONV_2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(CONV_2D::VT_LINK, link);
  }
  void add_fuse_node(int32_t fuse_node) {
    fbb_.AddElement<int32_t>(CONV_2D::VT_FUSE_NODE, fuse_node, 0);
  }
  void add_padding(const nn::Pads *padding) {
    fbb_.AddStruct(CONV_2D::VT_PADDING, padding);
  }
  void add_stride(const nn::Stride *stride) {
    fbb_.AddStruct(CONV_2D::VT_STRIDE, stride);
  }
  void add_dilation(const nn::Dilation *dilation) {
    fbb_.AddStruct(CONV_2D::VT_DILATION, dilation);
  }
  void add_group(const nn::Group *group) {
    fbb_.AddStruct(CONV_2D::VT_GROUP, group);
  }
  explicit CONV_2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CONV_2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CONV_2D>(end);
    fbb_.Required(o, CONV_2D::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<CONV_2D> CreateCONV_2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    int32_t fuse_node = 0,
    const nn::Pads *padding = nullptr,
    const nn::Stride *stride = nullptr,
    const nn::Dilation *dilation = nullptr,
    const nn::Group *group = nullptr) {
  CONV_2DBuilder builder_(_fbb);
  builder_.add_group(group);
  builder_.add_dilation(dilation);
  builder_.add_stride(stride);
  builder_.add_padding(padding);
  builder_.add_fuse_node(fuse_node);
  builder_.add_link(link);
  return builder_.Finish();
}

struct CONV_2D::Traits {
  using type = CONV_2D;
  static auto constexpr Create = CreateCONV_2D;
};

struct AVERAGE_POOL_2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AVERAGE_POOL_2DBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_PADDING = 6,
    VT_STRIDE = 8,
    VT_KERNEL_SHAPE = 10
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const nn::Pads *padding() const {
    return GetStruct<const nn::Pads *>(VT_PADDING);
  }
  const nn::Stride *stride() const {
    return GetStruct<const nn::Stride *>(VT_STRIDE);
  }
  const nn::KernelShape *kernel_shape() const {
    return GetStruct<const nn::KernelShape *>(VT_KERNEL_SHAPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<nn::Pads>(verifier, VT_PADDING, 4) &&
           VerifyField<nn::Stride>(verifier, VT_STRIDE, 4) &&
           VerifyField<nn::KernelShape>(verifier, VT_KERNEL_SHAPE, 4) &&
           verifier.EndTable();
  }
};

struct AVERAGE_POOL_2DBuilder {
  typedef AVERAGE_POOL_2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(AVERAGE_POOL_2D::VT_LINK, link);
  }
  void add_padding(const nn::Pads *padding) {
    fbb_.AddStruct(AVERAGE_POOL_2D::VT_PADDING, padding);
  }
  void add_stride(const nn::Stride *stride) {
    fbb_.AddStruct(AVERAGE_POOL_2D::VT_STRIDE, stride);
  }
  void add_kernel_shape(const nn::KernelShape *kernel_shape) {
    fbb_.AddStruct(AVERAGE_POOL_2D::VT_KERNEL_SHAPE, kernel_shape);
  }
  explicit AVERAGE_POOL_2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AVERAGE_POOL_2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AVERAGE_POOL_2D>(end);
    fbb_.Required(o, AVERAGE_POOL_2D::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<AVERAGE_POOL_2D> CreateAVERAGE_POOL_2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const nn::Pads *padding = nullptr,
    const nn::Stride *stride = nullptr,
    const nn::KernelShape *kernel_shape = nullptr) {
  AVERAGE_POOL_2DBuilder builder_(_fbb);
  builder_.add_kernel_shape(kernel_shape);
  builder_.add_stride(stride);
  builder_.add_padding(padding);
  builder_.add_link(link);
  return builder_.Finish();
}

struct AVERAGE_POOL_2D::Traits {
  using type = AVERAGE_POOL_2D;
  static auto constexpr Create = CreateAVERAGE_POOL_2D;
};

struct MAX_POOL_2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MAX_POOL_2DBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_PADDING = 6,
    VT_STRIDE = 8,
    VT_KERNEL_SHAPE = 10
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const nn::Pads *padding() const {
    return GetStruct<const nn::Pads *>(VT_PADDING);
  }
  const nn::Stride *stride() const {
    return GetStruct<const nn::Stride *>(VT_STRIDE);
  }
  const nn::KernelShape *kernel_shape() const {
    return GetStruct<const nn::KernelShape *>(VT_KERNEL_SHAPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<nn::Pads>(verifier, VT_PADDING, 4) &&
           VerifyField<nn::Stride>(verifier, VT_STRIDE, 4) &&
           VerifyField<nn::KernelShape>(verifier, VT_KERNEL_SHAPE, 4) &&
           verifier.EndTable();
  }
};

struct MAX_POOL_2DBuilder {
  typedef MAX_POOL_2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(MAX_POOL_2D::VT_LINK, link);
  }
  void add_padding(const nn::Pads *padding) {
    fbb_.AddStruct(MAX_POOL_2D::VT_PADDING, padding);
  }
  void add_stride(const nn::Stride *stride) {
    fbb_.AddStruct(MAX_POOL_2D::VT_STRIDE, stride);
  }
  void add_kernel_shape(const nn::KernelShape *kernel_shape) {
    fbb_.AddStruct(MAX_POOL_2D::VT_KERNEL_SHAPE, kernel_shape);
  }
  explicit MAX_POOL_2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MAX_POOL_2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MAX_POOL_2D>(end);
    fbb_.Required(o, MAX_POOL_2D::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<MAX_POOL_2D> CreateMAX_POOL_2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const nn::Pads *padding = nullptr,
    const nn::Stride *stride = nullptr,
    const nn::KernelShape *kernel_shape = nullptr) {
  MAX_POOL_2DBuilder builder_(_fbb);
  builder_.add_kernel_shape(kernel_shape);
  builder_.add_stride(stride);
  builder_.add_padding(padding);
  builder_.add_link(link);
  return builder_.Finish();
}

struct MAX_POOL_2D::Traits {
  using type = MAX_POOL_2D;
  static auto constexpr Create = CreateMAX_POOL_2D;
};

struct RELU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RELUBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct RELUBuilder {
  typedef RELU Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(RELU::VT_LINK, link);
  }
  explicit RELUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RELU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RELU>(end);
    fbb_.Required(o, RELU::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<RELU> CreateRELU(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  RELUBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct RELU::Traits {
  using type = RELU;
  static auto constexpr Create = CreateRELU;
};

struct SOFTMAX FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SOFTMAXBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_BETA = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<float>(verifier, VT_BETA, 4) &&
           verifier.EndTable();
  }
};

struct SOFTMAXBuilder {
  typedef SOFTMAX Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(SOFTMAX::VT_LINK, link);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(SOFTMAX::VT_BETA, beta, 0.0f);
  }
  explicit SOFTMAXBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SOFTMAX> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SOFTMAX>(end);
    fbb_.Required(o, SOFTMAX::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<SOFTMAX> CreateSOFTMAX(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    float beta = 0.0f) {
  SOFTMAXBuilder builder_(_fbb);
  builder_.add_beta(beta);
  builder_.add_link(link);
  return builder_.Finish();
}

struct SOFTMAX::Traits {
  using type = SOFTMAX;
  static auto constexpr Create = CreateSOFTMAX;
};

struct FULLY_CONNECTED FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FULLY_CONNECTEDBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_BIAS = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  float bias() const {
    return GetField<float>(VT_BIAS, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<float>(verifier, VT_BIAS, 4) &&
           verifier.EndTable();
  }
};

struct FULLY_CONNECTEDBuilder {
  typedef FULLY_CONNECTED Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(FULLY_CONNECTED::VT_LINK, link);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(FULLY_CONNECTED::VT_BIAS, bias, 0.0f);
  }
  explicit FULLY_CONNECTEDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FULLY_CONNECTED> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FULLY_CONNECTED>(end);
    fbb_.Required(o, FULLY_CONNECTED::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<FULLY_CONNECTED> CreateFULLY_CONNECTED(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    float bias = 0.0f) {
  FULLY_CONNECTEDBuilder builder_(_fbb);
  builder_.add_bias(bias);
  builder_.add_link(link);
  return builder_.Finish();
}

struct FULLY_CONNECTED::Traits {
  using type = FULLY_CONNECTED;
  static auto constexpr Create = CreateFULLY_CONNECTED;
};

struct ADD FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ADDBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct ADDBuilder {
  typedef ADD Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(ADD::VT_LINK, link);
  }
  explicit ADDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ADD> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ADD>(end);
    fbb_.Required(o, ADD::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<ADD> CreateADD(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  ADDBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct ADD::Traits {
  using type = ADD;
  static auto constexpr Create = CreateADD;
};

struct SUB FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SUBBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct SUBBuilder {
  typedef SUB Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(SUB::VT_LINK, link);
  }
  explicit SUBBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SUB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SUB>(end);
    fbb_.Required(o, SUB::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<SUB> CreateSUB(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  SUBBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct SUB::Traits {
  using type = SUB;
  static auto constexpr Create = CreateSUB;
};

struct MUL FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MULBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct MULBuilder {
  typedef MUL Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(MUL::VT_LINK, link);
  }
  explicit MULBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MUL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MUL>(end);
    fbb_.Required(o, MUL::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<MUL> CreateMUL(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  MULBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct MUL::Traits {
  using type = MUL;
  static auto constexpr Create = CreateMUL;
};

struct CONCATENATION FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CONCATENATIONBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_AXIS = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
};

struct CONCATENATIONBuilder {
  typedef CONCATENATION Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(CONCATENATION::VT_LINK, link);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(CONCATENATION::VT_AXIS, axis, 0);
  }
  explicit CONCATENATIONBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CONCATENATION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CONCATENATION>(end);
    fbb_.Required(o, CONCATENATION::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<CONCATENATION> CreateCONCATENATION(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    int32_t axis = 0) {
  CONCATENATIONBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_link(link);
  return builder_.Finish();
}

struct CONCATENATION::Traits {
  using type = CONCATENATION;
  static auto constexpr Create = CreateCONCATENATION;
};

struct DEPTHWISE_CONV_2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DEPTHWISE_CONV_2DBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_PADDING = 6,
    VT_STRIDE = 8,
    VT_DEPTH_MULTIPLIER = 10
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const nn::Pads *padding() const {
    return GetStruct<const nn::Pads *>(VT_PADDING);
  }
  const nn::Stride *stride() const {
    return GetStruct<const nn::Stride *>(VT_STRIDE);
  }
  int32_t depth_multiplier() const {
    return GetField<int32_t>(VT_DEPTH_MULTIPLIER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<nn::Pads>(verifier, VT_PADDING, 4) &&
           VerifyField<nn::Stride>(verifier, VT_STRIDE, 4) &&
           VerifyField<int32_t>(verifier, VT_DEPTH_MULTIPLIER, 4) &&
           verifier.EndTable();
  }
};

struct DEPTHWISE_CONV_2DBuilder {
  typedef DEPTHWISE_CONV_2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(DEPTHWISE_CONV_2D::VT_LINK, link);
  }
  void add_padding(const nn::Pads *padding) {
    fbb_.AddStruct(DEPTHWISE_CONV_2D::VT_PADDING, padding);
  }
  void add_stride(const nn::Stride *stride) {
    fbb_.AddStruct(DEPTHWISE_CONV_2D::VT_STRIDE, stride);
  }
  void add_depth_multiplier(int32_t depth_multiplier) {
    fbb_.AddElement<int32_t>(DEPTHWISE_CONV_2D::VT_DEPTH_MULTIPLIER, depth_multiplier, 0);
  }
  explicit DEPTHWISE_CONV_2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DEPTHWISE_CONV_2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DEPTHWISE_CONV_2D>(end);
    fbb_.Required(o, DEPTHWISE_CONV_2D::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<DEPTHWISE_CONV_2D> CreateDEPTHWISE_CONV_2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const nn::Pads *padding = nullptr,
    const nn::Stride *stride = nullptr,
    int32_t depth_multiplier = 0) {
  DEPTHWISE_CONV_2DBuilder builder_(_fbb);
  builder_.add_depth_multiplier(depth_multiplier);
  builder_.add_stride(stride);
  builder_.add_padding(padding);
  builder_.add_link(link);
  return builder_.Finish();
}

struct DEPTHWISE_CONV_2D::Traits {
  using type = DEPTHWISE_CONV_2D;
  static auto constexpr Create = CreateDEPTHWISE_CONV_2D;
};

struct BATCH_TO_SPACE_ND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BATCH_TO_SPACE_NDBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_BLOCK_SIZES = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const flatbuffers::Vector<int32_t> *block_sizes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCK_SIZES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyOffset(verifier, VT_BLOCK_SIZES) &&
           verifier.VerifyVector(block_sizes()) &&
           verifier.EndTable();
  }
};

struct BATCH_TO_SPACE_NDBuilder {
  typedef BATCH_TO_SPACE_ND Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(BATCH_TO_SPACE_ND::VT_LINK, link);
  }
  void add_block_sizes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_sizes) {
    fbb_.AddOffset(BATCH_TO_SPACE_ND::VT_BLOCK_SIZES, block_sizes);
  }
  explicit BATCH_TO_SPACE_NDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BATCH_TO_SPACE_ND> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BATCH_TO_SPACE_ND>(end);
    fbb_.Required(o, BATCH_TO_SPACE_ND::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<BATCH_TO_SPACE_ND> CreateBATCH_TO_SPACE_ND(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_sizes = 0) {
  BATCH_TO_SPACE_NDBuilder builder_(_fbb);
  builder_.add_block_sizes(block_sizes);
  builder_.add_link(link);
  return builder_.Finish();
}

struct BATCH_TO_SPACE_ND::Traits {
  using type = BATCH_TO_SPACE_ND;
  static auto constexpr Create = CreateBATCH_TO_SPACE_ND;
};

inline flatbuffers::Offset<BATCH_TO_SPACE_ND> CreateBATCH_TO_SPACE_NDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const std::vector<int32_t> *block_sizes = nullptr) {
  auto block_sizes__ = block_sizes ? _fbb.CreateVector<int32_t>(*block_sizes) : 0;
  return nn::CreateBATCH_TO_SPACE_ND(
      _fbb,
      link,
      block_sizes__);
}

struct SPACE_TO_BATCH_ND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SPACE_TO_BATCH_NDBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_BLOCK_SIZES = 6,
    VT_PADDING = 8
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const flatbuffers::Vector<int32_t> *block_sizes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCK_SIZES);
  }
  const nn::Pads *padding() const {
    return GetStruct<const nn::Pads *>(VT_PADDING);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyOffset(verifier, VT_BLOCK_SIZES) &&
           verifier.VerifyVector(block_sizes()) &&
           VerifyField<nn::Pads>(verifier, VT_PADDING, 4) &&
           verifier.EndTable();
  }
};

struct SPACE_TO_BATCH_NDBuilder {
  typedef SPACE_TO_BATCH_ND Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(SPACE_TO_BATCH_ND::VT_LINK, link);
  }
  void add_block_sizes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_sizes) {
    fbb_.AddOffset(SPACE_TO_BATCH_ND::VT_BLOCK_SIZES, block_sizes);
  }
  void add_padding(const nn::Pads *padding) {
    fbb_.AddStruct(SPACE_TO_BATCH_ND::VT_PADDING, padding);
  }
  explicit SPACE_TO_BATCH_NDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SPACE_TO_BATCH_ND> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SPACE_TO_BATCH_ND>(end);
    fbb_.Required(o, SPACE_TO_BATCH_ND::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<SPACE_TO_BATCH_ND> CreateSPACE_TO_BATCH_ND(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_sizes = 0,
    const nn::Pads *padding = nullptr) {
  SPACE_TO_BATCH_NDBuilder builder_(_fbb);
  builder_.add_padding(padding);
  builder_.add_block_sizes(block_sizes);
  builder_.add_link(link);
  return builder_.Finish();
}

struct SPACE_TO_BATCH_ND::Traits {
  using type = SPACE_TO_BATCH_ND;
  static auto constexpr Create = CreateSPACE_TO_BATCH_ND;
};

inline flatbuffers::Offset<SPACE_TO_BATCH_ND> CreateSPACE_TO_BATCH_NDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const std::vector<int32_t> *block_sizes = nullptr,
    const nn::Pads *padding = nullptr) {
  auto block_sizes__ = block_sizes ? _fbb.CreateVector<int32_t>(*block_sizes) : 0;
  return nn::CreateSPACE_TO_BATCH_ND(
      _fbb,
      link,
      block_sizes__,
      padding);
}

struct STRIDED_SLICE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef STRIDED_SLICEBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_STARTS = 6,
    VT_ENDS = 8,
    VT_STRIDES = 10,
    VT_BEGIN_MASK = 12,
    VT_END_MASK = 14,
    VT_SHRINK_AXIS_MASK = 16
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const flatbuffers::Vector<int32_t> *starts() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STARTS);
  }
  const flatbuffers::Vector<int32_t> *ends() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ENDS);
  }
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  int32_t begin_mask() const {
    return GetField<int32_t>(VT_BEGIN_MASK, 0);
  }
  int32_t end_mask() const {
    return GetField<int32_t>(VT_END_MASK, 0);
  }
  int32_t shrink_axis_mask() const {
    return GetField<int32_t>(VT_SHRINK_AXIS_MASK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyOffset(verifier, VT_STARTS) &&
           verifier.VerifyVector(starts()) &&
           VerifyOffset(verifier, VT_ENDS) &&
           verifier.VerifyVector(ends()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyField<int32_t>(verifier, VT_BEGIN_MASK, 4) &&
           VerifyField<int32_t>(verifier, VT_END_MASK, 4) &&
           VerifyField<int32_t>(verifier, VT_SHRINK_AXIS_MASK, 4) &&
           verifier.EndTable();
  }
};

struct STRIDED_SLICEBuilder {
  typedef STRIDED_SLICE Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(STRIDED_SLICE::VT_LINK, link);
  }
  void add_starts(flatbuffers::Offset<flatbuffers::Vector<int32_t>> starts) {
    fbb_.AddOffset(STRIDED_SLICE::VT_STARTS, starts);
  }
  void add_ends(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ends) {
    fbb_.AddOffset(STRIDED_SLICE::VT_ENDS, ends);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(STRIDED_SLICE::VT_STRIDES, strides);
  }
  void add_begin_mask(int32_t begin_mask) {
    fbb_.AddElement<int32_t>(STRIDED_SLICE::VT_BEGIN_MASK, begin_mask, 0);
  }
  void add_end_mask(int32_t end_mask) {
    fbb_.AddElement<int32_t>(STRIDED_SLICE::VT_END_MASK, end_mask, 0);
  }
  void add_shrink_axis_mask(int32_t shrink_axis_mask) {
    fbb_.AddElement<int32_t>(STRIDED_SLICE::VT_SHRINK_AXIS_MASK, shrink_axis_mask, 0);
  }
  explicit STRIDED_SLICEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<STRIDED_SLICE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<STRIDED_SLICE>(end);
    fbb_.Required(o, STRIDED_SLICE::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<STRIDED_SLICE> CreateSTRIDED_SLICE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> starts = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ends = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0,
    int32_t begin_mask = 0,
    int32_t end_mask = 0,
    int32_t shrink_axis_mask = 0) {
  STRIDED_SLICEBuilder builder_(_fbb);
  builder_.add_shrink_axis_mask(shrink_axis_mask);
  builder_.add_end_mask(end_mask);
  builder_.add_begin_mask(begin_mask);
  builder_.add_strides(strides);
  builder_.add_ends(ends);
  builder_.add_starts(starts);
  builder_.add_link(link);
  return builder_.Finish();
}

struct STRIDED_SLICE::Traits {
  using type = STRIDED_SLICE;
  static auto constexpr Create = CreateSTRIDED_SLICE;
};

inline flatbuffers::Offset<STRIDED_SLICE> CreateSTRIDED_SLICEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const std::vector<int32_t> *starts = nullptr,
    const std::vector<int32_t> *ends = nullptr,
    const std::vector<int32_t> *strides = nullptr,
    int32_t begin_mask = 0,
    int32_t end_mask = 0,
    int32_t shrink_axis_mask = 0) {
  auto starts__ = starts ? _fbb.CreateVector<int32_t>(*starts) : 0;
  auto ends__ = ends ? _fbb.CreateVector<int32_t>(*ends) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  return nn::CreateSTRIDED_SLICE(
      _fbb,
      link,
      starts__,
      ends__,
      strides__,
      begin_mask,
      end_mask,
      shrink_axis_mask);
}

struct DEQUANTIZE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DEQUANTIZEBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct DEQUANTIZEBuilder {
  typedef DEQUANTIZE Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(DEQUANTIZE::VT_LINK, link);
  }
  explicit DEQUANTIZEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DEQUANTIZE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DEQUANTIZE>(end);
    fbb_.Required(o, DEQUANTIZE::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<DEQUANTIZE> CreateDEQUANTIZE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  DEQUANTIZEBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct DEQUANTIZE::Traits {
  using type = DEQUANTIZE;
  static auto constexpr Create = CreateDEQUANTIZE;
};

struct LOCAL_RESPONSE_NORMALIZATION FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LOCAL_RESPONSE_NORMALIZATIONBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_RADIUS = 6,
    VT_BIAS = 8,
    VT_ALPHA = 10,
    VT_BETA = 12
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  int32_t radius() const {
    return GetField<int32_t>(VT_RADIUS, 0);
  }
  float bias() const {
    return GetField<float>(VT_BIAS, 0.0f);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<int32_t>(verifier, VT_RADIUS, 4) &&
           VerifyField<float>(verifier, VT_BIAS, 4) &&
           VerifyField<float>(verifier, VT_ALPHA, 4) &&
           VerifyField<float>(verifier, VT_BETA, 4) &&
           verifier.EndTable();
  }
};

struct LOCAL_RESPONSE_NORMALIZATIONBuilder {
  typedef LOCAL_RESPONSE_NORMALIZATION Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(LOCAL_RESPONSE_NORMALIZATION::VT_LINK, link);
  }
  void add_radius(int32_t radius) {
    fbb_.AddElement<int32_t>(LOCAL_RESPONSE_NORMALIZATION::VT_RADIUS, radius, 0);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(LOCAL_RESPONSE_NORMALIZATION::VT_BIAS, bias, 0.0f);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LOCAL_RESPONSE_NORMALIZATION::VT_ALPHA, alpha, 0.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(LOCAL_RESPONSE_NORMALIZATION::VT_BETA, beta, 0.0f);
  }
  explicit LOCAL_RESPONSE_NORMALIZATIONBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LOCAL_RESPONSE_NORMALIZATION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LOCAL_RESPONSE_NORMALIZATION>(end);
    fbb_.Required(o, LOCAL_RESPONSE_NORMALIZATION::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<LOCAL_RESPONSE_NORMALIZATION> CreateLOCAL_RESPONSE_NORMALIZATION(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    int32_t radius = 0,
    float bias = 0.0f,
    float alpha = 0.0f,
    float beta = 0.0f) {
  LOCAL_RESPONSE_NORMALIZATIONBuilder builder_(_fbb);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_bias(bias);
  builder_.add_radius(radius);
  builder_.add_link(link);
  return builder_.Finish();
}

struct LOCAL_RESPONSE_NORMALIZATION::Traits {
  using type = LOCAL_RESPONSE_NORMALIZATION;
  static auto constexpr Create = CreateLOCAL_RESPONSE_NORMALIZATION;
};

struct TANH FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TANHBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct TANHBuilder {
  typedef TANH Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(TANH::VT_LINK, link);
  }
  explicit TANHBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TANH> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TANH>(end);
    fbb_.Required(o, TANH::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<TANH> CreateTANH(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  TANHBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct TANH::Traits {
  using type = TANH;
  static auto constexpr Create = CreateTANH;
};

struct FLOOR FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FLOORBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct FLOORBuilder {
  typedef FLOOR Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(FLOOR::VT_LINK, link);
  }
  explicit FLOORBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FLOOR> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FLOOR>(end);
    fbb_.Required(o, FLOOR::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<FLOOR> CreateFLOOR(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  FLOORBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct FLOOR::Traits {
  using type = FLOOR;
  static auto constexpr Create = CreateFLOOR;
};

struct LOGISTIC FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LOGISTICBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct LOGISTICBuilder {
  typedef LOGISTIC Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(LOGISTIC::VT_LINK, link);
  }
  explicit LOGISTICBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LOGISTIC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LOGISTIC>(end);
    fbb_.Required(o, LOGISTIC::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<LOGISTIC> CreateLOGISTIC(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  LOGISTICBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct LOGISTIC::Traits {
  using type = LOGISTIC;
  static auto constexpr Create = CreateLOGISTIC;
};

struct PRELU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PRELUBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_ALPHA = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const flatbuffers::String *alpha() const {
    return GetPointer<const flatbuffers::String *>(VT_ALPHA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyOffset(verifier, VT_ALPHA) &&
           verifier.VerifyString(alpha()) &&
           verifier.EndTable();
  }
};

struct PRELUBuilder {
  typedef PRELU Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(PRELU::VT_LINK, link);
  }
  void add_alpha(flatbuffers::Offset<flatbuffers::String> alpha) {
    fbb_.AddOffset(PRELU::VT_ALPHA, alpha);
  }
  explicit PRELUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PRELU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PRELU>(end);
    fbb_.Required(o, PRELU::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<PRELU> CreatePRELU(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    flatbuffers::Offset<flatbuffers::String> alpha = 0) {
  PRELUBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  builder_.add_link(link);
  return builder_.Finish();
}

struct PRELU::Traits {
  using type = PRELU;
  static auto constexpr Create = CreatePRELU;
};

inline flatbuffers::Offset<PRELU> CreatePRELUDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const char *alpha = nullptr) {
  auto alpha__ = alpha ? _fbb.CreateString(alpha) : 0;
  return nn::CreatePRELU(
      _fbb,
      link,
      alpha__);
}

struct POW FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef POWBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_EXP = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const flatbuffers::String *exp() const {
    return GetPointer<const flatbuffers::String *>(VT_EXP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyOffset(verifier, VT_EXP) &&
           verifier.VerifyString(exp()) &&
           verifier.EndTable();
  }
};

struct POWBuilder {
  typedef POW Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(POW::VT_LINK, link);
  }
  void add_exp(flatbuffers::Offset<flatbuffers::String> exp) {
    fbb_.AddOffset(POW::VT_EXP, exp);
  }
  explicit POWBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<POW> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<POW>(end);
    fbb_.Required(o, POW::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<POW> CreatePOW(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    flatbuffers::Offset<flatbuffers::String> exp = 0) {
  POWBuilder builder_(_fbb);
  builder_.add_exp(exp);
  builder_.add_link(link);
  return builder_.Finish();
}

struct POW::Traits {
  using type = POW;
  static auto constexpr Create = CreatePOW;
};

inline flatbuffers::Offset<POW> CreatePOWDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const char *exp = nullptr) {
  auto exp__ = exp ? _fbb.CreateString(exp) : 0;
  return nn::CreatePOW(
      _fbb,
      link,
      exp__);
}

struct NEG FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NEGBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct NEGBuilder {
  typedef NEG Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(NEG::VT_LINK, link);
  }
  explicit NEGBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NEG> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NEG>(end);
    fbb_.Required(o, NEG::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<NEG> CreateNEG(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  NEGBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct NEG::Traits {
  using type = NEG;
  static auto constexpr Create = CreateNEG;
};

struct MINIMUM FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MINIMUMBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct MINIMUMBuilder {
  typedef MINIMUM Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(MINIMUM::VT_LINK, link);
  }
  explicit MINIMUMBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MINIMUM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MINIMUM>(end);
    fbb_.Required(o, MINIMUM::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<MINIMUM> CreateMINIMUM(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  MINIMUMBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct MINIMUM::Traits {
  using type = MINIMUM;
  static auto constexpr Create = CreateMINIMUM;
};

struct MAXIMUM FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MAXIMUMBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct MAXIMUMBuilder {
  typedef MAXIMUM Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(MAXIMUM::VT_LINK, link);
  }
  explicit MAXIMUMBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MAXIMUM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MAXIMUM>(end);
    fbb_.Required(o, MAXIMUM::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<MAXIMUM> CreateMAXIMUM(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  MAXIMUMBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct MAXIMUM::Traits {
  using type = MAXIMUM;
  static auto constexpr Create = CreateMAXIMUM;
};

struct LOG FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LOGBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct LOGBuilder {
  typedef LOG Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(LOG::VT_LINK, link);
  }
  explicit LOGBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LOG> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LOG>(end);
    fbb_.Required(o, LOG::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<LOG> CreateLOG(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  LOGBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct LOG::Traits {
  using type = LOG;
  static auto constexpr Create = CreateLOG;
};

struct ABS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ABSBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct ABSBuilder {
  typedef ABS Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(ABS::VT_LINK, link);
  }
  explicit ABSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ABS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ABS>(end);
    fbb_.Required(o, ABS::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<ABS> CreateABS(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  ABSBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct ABS::Traits {
  using type = ABS;
  static auto constexpr Create = CreateABS;
};

struct EXP FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EXPBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct EXPBuilder {
  typedef EXP Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(EXP::VT_LINK, link);
  }
  explicit EXPBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EXP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EXP>(end);
    fbb_.Required(o, EXP::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<EXP> CreateEXP(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  EXPBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct EXP::Traits {
  using type = EXP;
  static auto constexpr Create = CreateEXP;
};

struct GATHER FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GATHERBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_AXIS = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
};

struct GATHERBuilder {
  typedef GATHER Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(GATHER::VT_LINK, link);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(GATHER::VT_AXIS, axis, 0);
  }
  explicit GATHERBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GATHER> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GATHER>(end);
    fbb_.Required(o, GATHER::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<GATHER> CreateGATHER(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    int32_t axis = 0) {
  GATHERBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_link(link);
  return builder_.Finish();
}

struct GATHER::Traits {
  using type = GATHER;
  static auto constexpr Create = CreateGATHER;
};

struct RESHAPE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RESHAPEBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_AXES = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const flatbuffers::Vector<int32_t> *axes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyOffset(verifier, VT_AXES) &&
           verifier.VerifyVector(axes()) &&
           verifier.EndTable();
  }
};

struct RESHAPEBuilder {
  typedef RESHAPE Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(RESHAPE::VT_LINK, link);
  }
  void add_axes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axes) {
    fbb_.AddOffset(RESHAPE::VT_AXES, axes);
  }
  explicit RESHAPEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RESHAPE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RESHAPE>(end);
    fbb_.Required(o, RESHAPE::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<RESHAPE> CreateRESHAPE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axes = 0) {
  RESHAPEBuilder builder_(_fbb);
  builder_.add_axes(axes);
  builder_.add_link(link);
  return builder_.Finish();
}

struct RESHAPE::Traits {
  using type = RESHAPE;
  static auto constexpr Create = CreateRESHAPE;
};

inline flatbuffers::Offset<RESHAPE> CreateRESHAPEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const std::vector<int32_t> *axes = nullptr) {
  auto axes__ = axes ? _fbb.CreateVector<int32_t>(*axes) : 0;
  return nn::CreateRESHAPE(
      _fbb,
      link,
      axes__);
}

struct Configure FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConfigureBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_GATHER_INDICES = 6,
    VT_GATHER_AXIS = 8,
    VT_UNSQUEEZE_AXES = 10,
    VT_CONCAT_AXIS = 12,
    VT_CONCAT = 14
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const flatbuffers::Vector<int32_t> *gather_indices() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_GATHER_INDICES);
  }
  int32_t gather_axis() const {
    return GetField<int32_t>(VT_GATHER_AXIS, 0);
  }
  const flatbuffers::Vector<int32_t> *unsqueeze_axes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_UNSQUEEZE_AXES);
  }
  int32_t concat_axis() const {
    return GetField<int32_t>(VT_CONCAT_AXIS, 0);
  }
  const flatbuffers::Vector<int32_t> *concat() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CONCAT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyOffset(verifier, VT_GATHER_INDICES) &&
           verifier.VerifyVector(gather_indices()) &&
           VerifyField<int32_t>(verifier, VT_GATHER_AXIS, 4) &&
           VerifyOffset(verifier, VT_UNSQUEEZE_AXES) &&
           verifier.VerifyVector(unsqueeze_axes()) &&
           VerifyField<int32_t>(verifier, VT_CONCAT_AXIS, 4) &&
           VerifyOffset(verifier, VT_CONCAT) &&
           verifier.VerifyVector(concat()) &&
           verifier.EndTable();
  }
};

struct ConfigureBuilder {
  typedef Configure Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(Configure::VT_LINK, link);
  }
  void add_gather_indices(flatbuffers::Offset<flatbuffers::Vector<int32_t>> gather_indices) {
    fbb_.AddOffset(Configure::VT_GATHER_INDICES, gather_indices);
  }
  void add_gather_axis(int32_t gather_axis) {
    fbb_.AddElement<int32_t>(Configure::VT_GATHER_AXIS, gather_axis, 0);
  }
  void add_unsqueeze_axes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> unsqueeze_axes) {
    fbb_.AddOffset(Configure::VT_UNSQUEEZE_AXES, unsqueeze_axes);
  }
  void add_concat_axis(int32_t concat_axis) {
    fbb_.AddElement<int32_t>(Configure::VT_CONCAT_AXIS, concat_axis, 0);
  }
  void add_concat(flatbuffers::Offset<flatbuffers::Vector<int32_t>> concat) {
    fbb_.AddOffset(Configure::VT_CONCAT, concat);
  }
  explicit ConfigureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Configure> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Configure>(end);
    fbb_.Required(o, Configure::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<Configure> CreateConfigure(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> gather_indices = 0,
    int32_t gather_axis = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> unsqueeze_axes = 0,
    int32_t concat_axis = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> concat = 0) {
  ConfigureBuilder builder_(_fbb);
  builder_.add_concat(concat);
  builder_.add_concat_axis(concat_axis);
  builder_.add_unsqueeze_axes(unsqueeze_axes);
  builder_.add_gather_axis(gather_axis);
  builder_.add_gather_indices(gather_indices);
  builder_.add_link(link);
  return builder_.Finish();
}

struct Configure::Traits {
  using type = Configure;
  static auto constexpr Create = CreateConfigure;
};

inline flatbuffers::Offset<Configure> CreateConfigureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const std::vector<int32_t> *gather_indices = nullptr,
    int32_t gather_axis = 0,
    const std::vector<int32_t> *unsqueeze_axes = nullptr,
    int32_t concat_axis = 0,
    const std::vector<int32_t> *concat = nullptr) {
  auto gather_indices__ = gather_indices ? _fbb.CreateVector<int32_t>(*gather_indices) : 0;
  auto unsqueeze_axes__ = unsqueeze_axes ? _fbb.CreateVector<int32_t>(*unsqueeze_axes) : 0;
  auto concat__ = concat ? _fbb.CreateVector<int32_t>(*concat) : 0;
  return nn::CreateConfigure(
      _fbb,
      link,
      gather_indices__,
      gather_axis,
      unsqueeze_axes__,
      concat_axis,
      concat__);
}

struct Output FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OutputBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODE_IDX = 4,
    VT_SHAPE = 6
  };
  int32_t node_idx() const {
    return GetField<int32_t>(VT_NODE_IDX, 0);
  }
  const nn::TensorShape *shape() const {
    return GetPointer<const nn::TensorShape *>(VT_SHAPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NODE_IDX, 4) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyTable(shape()) &&
           verifier.EndTable();
  }
};

struct OutputBuilder {
  typedef Output Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node_idx(int32_t node_idx) {
    fbb_.AddElement<int32_t>(Output::VT_NODE_IDX, node_idx, 0);
  }
  void add_shape(flatbuffers::Offset<nn::TensorShape> shape) {
    fbb_.AddOffset(Output::VT_SHAPE, shape);
  }
  explicit OutputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Output> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Output>(end);
    return o;
  }
};

inline flatbuffers::Offset<Output> CreateOutput(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t node_idx = 0,
    flatbuffers::Offset<nn::TensorShape> shape = 0) {
  OutputBuilder builder_(_fbb);
  builder_.add_shape(shape);
  builder_.add_node_idx(node_idx);
  return builder_.Finish();
}

struct Output::Traits {
  using type = Output;
  static auto constexpr Create = CreateOutput;
};

struct Graph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GraphBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_NODE_TYPE = 6,
    VT_NODE = 8,
    VT_OUTPUTS = 10,
    VT_QUANT_INFOS = 12
  };
  const nn::versionInfo *version() const {
    return GetStruct<const nn::versionInfo *>(VT_VERSION);
  }
  const flatbuffers::Vector<nn::Layer> *node_type() const {
    return GetPointer<const flatbuffers::Vector<nn::Layer> *>(VT_NODE_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *node() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_NODE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<nn::Output>> *outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<nn::Output>> *>(VT_OUTPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<nn::QuantInfo>> *quant_infos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<nn::QuantInfo>> *>(VT_QUANT_INFOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<nn::versionInfo>(verifier, VT_VERSION, 8) &&
           VerifyOffset(verifier, VT_NODE_TYPE) &&
           verifier.VerifyVector(node_type()) &&
           VerifyOffset(verifier, VT_NODE) &&
           verifier.VerifyVector(node()) &&
           VerifyLayerVector(verifier, node(), node_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfTables(outputs()) &&
           VerifyOffset(verifier, VT_QUANT_INFOS) &&
           verifier.VerifyVector(quant_infos()) &&
           verifier.VerifyVectorOfTables(quant_infos()) &&
           verifier.EndTable();
  }
};

struct GraphBuilder {
  typedef Graph Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(const nn::versionInfo *version) {
    fbb_.AddStruct(Graph::VT_VERSION, version);
  }
  void add_node_type(flatbuffers::Offset<flatbuffers::Vector<nn::Layer>> node_type) {
    fbb_.AddOffset(Graph::VT_NODE_TYPE, node_type);
  }
  void add_node(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> node) {
    fbb_.AddOffset(Graph::VT_NODE, node);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<nn::Output>>> outputs) {
    fbb_.AddOffset(Graph::VT_OUTPUTS, outputs);
  }
  void add_quant_infos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<nn::QuantInfo>>> quant_infos) {
    fbb_.AddOffset(Graph::VT_QUANT_INFOS, quant_infos);
  }
  explicit GraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Graph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Graph>(end);
    return o;
  }
};

inline flatbuffers::Offset<Graph> CreateGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    const nn::versionInfo *version = nullptr,
    flatbuffers::Offset<flatbuffers::Vector<nn::Layer>> node_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> node = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<nn::Output>>> outputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<nn::QuantInfo>>> quant_infos = 0) {
  GraphBuilder builder_(_fbb);
  builder_.add_quant_infos(quant_infos);
  builder_.add_outputs(outputs);
  builder_.add_node(node);
  builder_.add_node_type(node_type);
  builder_.add_version(version);
  return builder_.Finish();
}

struct Graph::Traits {
  using type = Graph;
  static auto constexpr Create = CreateGraph;
};

inline flatbuffers::Offset<Graph> CreateGraphDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const nn::versionInfo *version = nullptr,
    const std::vector<nn::Layer> *node_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *node = nullptr,
    const std::vector<flatbuffers::Offset<nn::Output>> *outputs = nullptr,
    const std::vector<flatbuffers::Offset<nn::QuantInfo>> *quant_infos = nullptr) {
  auto node_type__ = node_type ? _fbb.CreateVector<nn::Layer>(*node_type) : 0;
  auto node__ = node ? _fbb.CreateVector<flatbuffers::Offset<void>>(*node) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<flatbuffers::Offset<nn::Output>>(*outputs) : 0;
  auto quant_infos__ = quant_infos ? _fbb.CreateVector<flatbuffers::Offset<nn::QuantInfo>>(*quant_infos) : 0;
  return nn::CreateGraph(
      _fbb,
      version,
      node_type__,
      node__,
      outputs__,
      quant_infos__);
}

inline bool VerifyDim(flatbuffers::Verifier &verifier, const void *obj, Dim type) {
  switch (type) {
    case Dim::NONE: {
      return true;
    }
    case Dim::DimValue: {
      return verifier.VerifyField<nn::DimValue>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    case Dim::DimParam: {
      auto ptr = reinterpret_cast<const nn::DimParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyDimVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<Dim> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyDim(
        verifier,  values->Get(i), types->GetEnum<Dim>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyLayer(flatbuffers::Verifier &verifier, const void *obj, Layer type) {
  switch (type) {
    case Layer::NONE: {
      return true;
    }
    case Layer::InputTensor: {
      auto ptr = reinterpret_cast<const nn::InputTensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::RawTensor: {
      auto ptr = reinterpret_cast<const nn::RawTensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::I32Scalar: {
      return verifier.VerifyField<nn::I32Scalar>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    case Layer::U32Scalar: {
      return verifier.VerifyField<nn::U32Scalar>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    case Layer::FuseNode: {
      return verifier.VerifyField<nn::FuseNode>(static_cast<const uint8_t *>(obj), 0, 1);
    }
    case Layer::I32Tensor: {
      auto ptr = reinterpret_cast<const nn::I32Tensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::U32Tensor: {
      auto ptr = reinterpret_cast<const nn::U32Tensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::F16Tensor: {
      auto ptr = reinterpret_cast<const nn::F16Tensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::F32Tensor: {
      auto ptr = reinterpret_cast<const nn::F32Tensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::F64Tensor: {
      auto ptr = reinterpret_cast<const nn::F64Tensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::CONV_2D: {
      auto ptr = reinterpret_cast<const nn::CONV_2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::AVERAGE_POOL_2D: {
      auto ptr = reinterpret_cast<const nn::AVERAGE_POOL_2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::MAX_POOL_2D: {
      auto ptr = reinterpret_cast<const nn::MAX_POOL_2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::RELU: {
      auto ptr = reinterpret_cast<const nn::RELU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::SOFTMAX: {
      auto ptr = reinterpret_cast<const nn::SOFTMAX *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::FULLY_CONNECTED: {
      auto ptr = reinterpret_cast<const nn::FULLY_CONNECTED *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::ADD: {
      auto ptr = reinterpret_cast<const nn::ADD *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::CONCATENATION: {
      auto ptr = reinterpret_cast<const nn::CONCATENATION *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::DEPTHWISE_CONV_2D: {
      auto ptr = reinterpret_cast<const nn::DEPTHWISE_CONV_2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::BATCH_TO_SPACE_ND: {
      auto ptr = reinterpret_cast<const nn::BATCH_TO_SPACE_ND *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::SPACE_TO_BATCH_ND: {
      auto ptr = reinterpret_cast<const nn::SPACE_TO_BATCH_ND *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::STRIDED_SLICE: {
      auto ptr = reinterpret_cast<const nn::STRIDED_SLICE *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::MUL: {
      auto ptr = reinterpret_cast<const nn::MUL *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::DEQUANTIZE: {
      auto ptr = reinterpret_cast<const nn::DEQUANTIZE *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::LOCAL_RESPONSE_NORMALIZATION: {
      auto ptr = reinterpret_cast<const nn::LOCAL_RESPONSE_NORMALIZATION *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::TANH: {
      auto ptr = reinterpret_cast<const nn::TANH *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::FLOOR: {
      auto ptr = reinterpret_cast<const nn::FLOOR *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::LOGISTIC: {
      auto ptr = reinterpret_cast<const nn::LOGISTIC *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::PRELU: {
      auto ptr = reinterpret_cast<const nn::PRELU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::POW: {
      auto ptr = reinterpret_cast<const nn::POW *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::NEG: {
      auto ptr = reinterpret_cast<const nn::NEG *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::MINIMUM: {
      auto ptr = reinterpret_cast<const nn::MINIMUM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::MAXIMUM: {
      auto ptr = reinterpret_cast<const nn::MAXIMUM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::LOG: {
      auto ptr = reinterpret_cast<const nn::LOG *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::ABS: {
      auto ptr = reinterpret_cast<const nn::ABS *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::EXP: {
      auto ptr = reinterpret_cast<const nn::EXP *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::SUB: {
      auto ptr = reinterpret_cast<const nn::SUB *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::GATHER: {
      auto ptr = reinterpret_cast<const nn::GATHER *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::RESHAPE: {
      auto ptr = reinterpret_cast<const nn::RESHAPE *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::Configure: {
      auto ptr = reinterpret_cast<const nn::Configure *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyLayerVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<Layer> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyLayer(
        verifier,  values->Get(i), types->GetEnum<Layer>(i))) {
      return false;
    }
  }
  return true;
}

inline const nn::Graph *GetGraph(const void *buf) {
  return flatbuffers::GetRoot<nn::Graph>(buf);
}

inline const nn::Graph *GetSizePrefixedGraph(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<nn::Graph>(buf);
}

inline bool VerifyGraphBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<nn::Graph>(nullptr);
}

inline bool VerifySizePrefixedGraphBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<nn::Graph>(nullptr);
}

inline void FinishGraphBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<nn::Graph> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedGraphBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<nn::Graph> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace nn

#endif  // FLATBUFFERS_GENERATED_GNT_NN_H_
