// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GNT_NN_H_
#define FLATBUFFERS_GENERATED_GNT_NN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 22 &&
              FLATBUFFERS_VERSION_MINOR == 10 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace nn {

struct versionInfo;

struct TensorInfo;
struct TensorInfoBuilder;

struct ubyteTensor;
struct ubyteTensorBuilder;

struct ushortTensor;
struct ushortTensorBuilder;

struct uintTensor;
struct uintTensorBuilder;

struct intTensor;
struct intTensorBuilder;

struct floatTensor;
struct floatTensorBuilder;

struct doubleTensor;
struct doubleTensorBuilder;

struct QuantInfo;
struct QuantInfoBuilder;

struct Input;
struct InputBuilder;

struct LinkOd;
struct LinkOdBuilder;

struct Link;
struct LinkBuilder;

struct Pads;

struct Stride;

struct Dilation;

struct KernelShape;

struct Group;

struct CONV_2D;
struct CONV_2DBuilder;

struct AVERAGE_POOL_2D;
struct AVERAGE_POOL_2DBuilder;

struct MAX_POOL_2D;
struct MAX_POOL_2DBuilder;

struct RELU;
struct RELUBuilder;

struct SOFTMAX;
struct SOFTMAXBuilder;

struct FULLY_CONNECTED;
struct FULLY_CONNECTEDBuilder;

struct ADD;
struct ADDBuilder;

struct SUB;
struct SUBBuilder;

struct MUL;
struct MULBuilder;

struct CONCATENATION;
struct CONCATENATIONBuilder;

struct DEPTHWISE_CONV_2D;
struct DEPTHWISE_CONV_2DBuilder;

struct BATCH_TO_SPACE_ND;
struct BATCH_TO_SPACE_NDBuilder;

struct SPACE_TO_BATCH_ND;
struct SPACE_TO_BATCH_NDBuilder;

struct STRIDED_SLICE;
struct STRIDED_SLICEBuilder;

struct DEQUANTIZE;
struct DEQUANTIZEBuilder;

struct LOCAL_RESPONSE_NORMALIZATION;
struct LOCAL_RESPONSE_NORMALIZATIONBuilder;

struct TANH;
struct TANHBuilder;

struct FLOOR;
struct FLOORBuilder;

struct LOGISTIC;
struct LOGISTICBuilder;

struct PRELU;
struct PRELUBuilder;

struct POW;
struct POWBuilder;

struct NEG;
struct NEGBuilder;

struct MINIMUM;
struct MINIMUMBuilder;

struct MAXIMUM;
struct MAXIMUMBuilder;

struct LOG;
struct LOGBuilder;

struct ABS;
struct ABSBuilder;

struct EXP;
struct EXPBuilder;

struct GATHER;
struct GATHERBuilder;

struct RESHAPE;
struct RESHAPEBuilder;

struct Graph;
struct GraphBuilder;

enum class DataType : int8_t {
  Float = 0,
  Int = 1,
  QuantAsymm = 2,
  QuantSymm = 3,
  QuantSymmPerChannel = 4,
  MIN = Float,
  MAX = QuantSymmPerChannel
};

inline const DataType (&EnumValuesDataType())[5] {
  static const DataType values[] = {
    DataType::Float,
    DataType::Int,
    DataType::QuantAsymm,
    DataType::QuantSymm,
    DataType::QuantSymmPerChannel
  };
  return values;
}

inline const char * const *EnumNamesDataType() {
  static const char * const names[6] = {
    "Float",
    "Int",
    "QuantAsymm",
    "QuantSymm",
    "QuantSymmPerChannel",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataType(DataType e) {
  if (flatbuffers::IsOutRange(e, DataType::Float, DataType::QuantSymmPerChannel)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataType()[index];
}

enum class FuseCode : int8_t {
  Relu = 0,
  Relu1 = 1,
  Relu6 = 2,
  MIN = Relu,
  MAX = Relu6
};

inline const FuseCode (&EnumValuesFuseCode())[3] {
  static const FuseCode values[] = {
    FuseCode::Relu,
    FuseCode::Relu1,
    FuseCode::Relu6
  };
  return values;
}

inline const char * const *EnumNamesFuseCode() {
  static const char * const names[4] = {
    "Relu",
    "Relu1",
    "Relu6",
    nullptr
  };
  return names;
}

inline const char *EnumNameFuseCode(FuseCode e) {
  if (flatbuffers::IsOutRange(e, FuseCode::Relu, FuseCode::Relu6)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFuseCode()[index];
}

enum class Tensor : uint8_t {
  NONE = 0,
  ubyteTensor = 1,
  ushortTensor = 2,
  uintTensor = 3,
  intTensor = 4,
  floatTensor = 5,
  doubleTensor = 6,
  MIN = NONE,
  MAX = doubleTensor
};

inline const Tensor (&EnumValuesTensor())[7] {
  static const Tensor values[] = {
    Tensor::NONE,
    Tensor::ubyteTensor,
    Tensor::ushortTensor,
    Tensor::uintTensor,
    Tensor::intTensor,
    Tensor::floatTensor,
    Tensor::doubleTensor
  };
  return values;
}

inline const char * const *EnumNamesTensor() {
  static const char * const names[8] = {
    "NONE",
    "ubyteTensor",
    "ushortTensor",
    "uintTensor",
    "intTensor",
    "floatTensor",
    "doubleTensor",
    nullptr
  };
  return names;
}

inline const char *EnumNameTensor(Tensor e) {
  if (flatbuffers::IsOutRange(e, Tensor::NONE, Tensor::doubleTensor)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTensor()[index];
}

template<typename T> struct TensorTraits {
  static const Tensor enum_value = Tensor::NONE;
};

template<> struct TensorTraits<nn::ubyteTensor> {
  static const Tensor enum_value = Tensor::ubyteTensor;
};

template<> struct TensorTraits<nn::ushortTensor> {
  static const Tensor enum_value = Tensor::ushortTensor;
};

template<> struct TensorTraits<nn::uintTensor> {
  static const Tensor enum_value = Tensor::uintTensor;
};

template<> struct TensorTraits<nn::intTensor> {
  static const Tensor enum_value = Tensor::intTensor;
};

template<> struct TensorTraits<nn::floatTensor> {
  static const Tensor enum_value = Tensor::floatTensor;
};

template<> struct TensorTraits<nn::doubleTensor> {
  static const Tensor enum_value = Tensor::doubleTensor;
};

bool VerifyTensor(flatbuffers::Verifier &verifier, const void *obj, Tensor type);
bool VerifyTensorVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<Tensor> *types);

enum class Layer : uint8_t {
  NONE = 0,
  CONV_2D = 1,
  AVERAGE_POOL_2D = 2,
  MAX_POOL_2D = 3,
  RELU = 4,
  SOFTMAX = 5,
  FULLY_CONNECTED = 6,
  ADD = 7,
  CONCATENATION = 8,
  DEPTHWISE_CONV_2D = 9,
  BATCH_TO_SPACE_ND = 10,
  SPACE_TO_BATCH_ND = 11,
  STRIDED_SLICE = 12,
  MUL = 13,
  DEQUANTIZE = 14,
  LOCAL_RESPONSE_NORMALIZATION = 15,
  TANH = 16,
  FLOOR = 17,
  LOGISTIC = 18,
  PRELU = 19,
  POW = 20,
  NEG = 21,
  MINIMUM = 22,
  MAXIMUM = 23,
  LOG = 24,
  ABS = 25,
  EXP = 26,
  SUB = 27,
  GATHER = 28,
  RESHAPE = 29,
  MIN = NONE,
  MAX = RESHAPE
};

inline const Layer (&EnumValuesLayer())[30] {
  static const Layer values[] = {
    Layer::NONE,
    Layer::CONV_2D,
    Layer::AVERAGE_POOL_2D,
    Layer::MAX_POOL_2D,
    Layer::RELU,
    Layer::SOFTMAX,
    Layer::FULLY_CONNECTED,
    Layer::ADD,
    Layer::CONCATENATION,
    Layer::DEPTHWISE_CONV_2D,
    Layer::BATCH_TO_SPACE_ND,
    Layer::SPACE_TO_BATCH_ND,
    Layer::STRIDED_SLICE,
    Layer::MUL,
    Layer::DEQUANTIZE,
    Layer::LOCAL_RESPONSE_NORMALIZATION,
    Layer::TANH,
    Layer::FLOOR,
    Layer::LOGISTIC,
    Layer::PRELU,
    Layer::POW,
    Layer::NEG,
    Layer::MINIMUM,
    Layer::MAXIMUM,
    Layer::LOG,
    Layer::ABS,
    Layer::EXP,
    Layer::SUB,
    Layer::GATHER,
    Layer::RESHAPE
  };
  return values;
}

inline const char * const *EnumNamesLayer() {
  static const char * const names[31] = {
    "NONE",
    "CONV_2D",
    "AVERAGE_POOL_2D",
    "MAX_POOL_2D",
    "RELU",
    "SOFTMAX",
    "FULLY_CONNECTED",
    "ADD",
    "CONCATENATION",
    "DEPTHWISE_CONV_2D",
    "BATCH_TO_SPACE_ND",
    "SPACE_TO_BATCH_ND",
    "STRIDED_SLICE",
    "MUL",
    "DEQUANTIZE",
    "LOCAL_RESPONSE_NORMALIZATION",
    "TANH",
    "FLOOR",
    "LOGISTIC",
    "PRELU",
    "POW",
    "NEG",
    "MINIMUM",
    "MAXIMUM",
    "LOG",
    "ABS",
    "EXP",
    "SUB",
    "GATHER",
    "RESHAPE",
    nullptr
  };
  return names;
}

inline const char *EnumNameLayer(Layer e) {
  if (flatbuffers::IsOutRange(e, Layer::NONE, Layer::RESHAPE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLayer()[index];
}

template<typename T> struct LayerTraits {
  static const Layer enum_value = Layer::NONE;
};

template<> struct LayerTraits<nn::CONV_2D> {
  static const Layer enum_value = Layer::CONV_2D;
};

template<> struct LayerTraits<nn::AVERAGE_POOL_2D> {
  static const Layer enum_value = Layer::AVERAGE_POOL_2D;
};

template<> struct LayerTraits<nn::MAX_POOL_2D> {
  static const Layer enum_value = Layer::MAX_POOL_2D;
};

template<> struct LayerTraits<nn::RELU> {
  static const Layer enum_value = Layer::RELU;
};

template<> struct LayerTraits<nn::SOFTMAX> {
  static const Layer enum_value = Layer::SOFTMAX;
};

template<> struct LayerTraits<nn::FULLY_CONNECTED> {
  static const Layer enum_value = Layer::FULLY_CONNECTED;
};

template<> struct LayerTraits<nn::ADD> {
  static const Layer enum_value = Layer::ADD;
};

template<> struct LayerTraits<nn::CONCATENATION> {
  static const Layer enum_value = Layer::CONCATENATION;
};

template<> struct LayerTraits<nn::DEPTHWISE_CONV_2D> {
  static const Layer enum_value = Layer::DEPTHWISE_CONV_2D;
};

template<> struct LayerTraits<nn::BATCH_TO_SPACE_ND> {
  static const Layer enum_value = Layer::BATCH_TO_SPACE_ND;
};

template<> struct LayerTraits<nn::SPACE_TO_BATCH_ND> {
  static const Layer enum_value = Layer::SPACE_TO_BATCH_ND;
};

template<> struct LayerTraits<nn::STRIDED_SLICE> {
  static const Layer enum_value = Layer::STRIDED_SLICE;
};

template<> struct LayerTraits<nn::MUL> {
  static const Layer enum_value = Layer::MUL;
};

template<> struct LayerTraits<nn::DEQUANTIZE> {
  static const Layer enum_value = Layer::DEQUANTIZE;
};

template<> struct LayerTraits<nn::LOCAL_RESPONSE_NORMALIZATION> {
  static const Layer enum_value = Layer::LOCAL_RESPONSE_NORMALIZATION;
};

template<> struct LayerTraits<nn::TANH> {
  static const Layer enum_value = Layer::TANH;
};

template<> struct LayerTraits<nn::FLOOR> {
  static const Layer enum_value = Layer::FLOOR;
};

template<> struct LayerTraits<nn::LOGISTIC> {
  static const Layer enum_value = Layer::LOGISTIC;
};

template<> struct LayerTraits<nn::PRELU> {
  static const Layer enum_value = Layer::PRELU;
};

template<> struct LayerTraits<nn::POW> {
  static const Layer enum_value = Layer::POW;
};

template<> struct LayerTraits<nn::NEG> {
  static const Layer enum_value = Layer::NEG;
};

template<> struct LayerTraits<nn::MINIMUM> {
  static const Layer enum_value = Layer::MINIMUM;
};

template<> struct LayerTraits<nn::MAXIMUM> {
  static const Layer enum_value = Layer::MAXIMUM;
};

template<> struct LayerTraits<nn::LOG> {
  static const Layer enum_value = Layer::LOG;
};

template<> struct LayerTraits<nn::ABS> {
  static const Layer enum_value = Layer::ABS;
};

template<> struct LayerTraits<nn::EXP> {
  static const Layer enum_value = Layer::EXP;
};

template<> struct LayerTraits<nn::SUB> {
  static const Layer enum_value = Layer::SUB;
};

template<> struct LayerTraits<nn::GATHER> {
  static const Layer enum_value = Layer::GATHER;
};

template<> struct LayerTraits<nn::RESHAPE> {
  static const Layer enum_value = Layer::RESHAPE;
};

bool VerifyLayer(flatbuffers::Verifier &verifier, const void *obj, Layer type);
bool VerifyLayerVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<Layer> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) versionInfo FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t codeversion_;
  int64_t dataversion_;

 public:
  struct Traits;
  versionInfo()
      : codeversion_(0),
        dataversion_(0) {
  }
  versionInfo(uint64_t _codeversion, int64_t _dataversion)
      : codeversion_(flatbuffers::EndianScalar(_codeversion)),
        dataversion_(flatbuffers::EndianScalar(_dataversion)) {
  }
  uint64_t codeversion() const {
    return flatbuffers::EndianScalar(codeversion_);
  }
  int64_t dataversion() const {
    return flatbuffers::EndianScalar(dataversion_);
  }
};
FLATBUFFERS_STRUCT_END(versionInfo, 16);

struct versionInfo::Traits {
  using type = versionInfo;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Pads FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t left_;
  int32_t right_;
  int32_t top_;
  int32_t bottom_;

 public:
  struct Traits;
  Pads()
      : left_(0),
        right_(0),
        top_(0),
        bottom_(0) {
  }
  Pads(int32_t _left, int32_t _right, int32_t _top, int32_t _bottom)
      : left_(flatbuffers::EndianScalar(_left)),
        right_(flatbuffers::EndianScalar(_right)),
        top_(flatbuffers::EndianScalar(_top)),
        bottom_(flatbuffers::EndianScalar(_bottom)) {
  }
  int32_t left() const {
    return flatbuffers::EndianScalar(left_);
  }
  int32_t right() const {
    return flatbuffers::EndianScalar(right_);
  }
  int32_t top() const {
    return flatbuffers::EndianScalar(top_);
  }
  int32_t bottom() const {
    return flatbuffers::EndianScalar(bottom_);
  }
};
FLATBUFFERS_STRUCT_END(Pads, 16);

struct Pads::Traits {
  using type = Pads;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Stride FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;

 public:
  struct Traits;
  Stride()
      : x_(0),
        y_(0) {
  }
  Stride(int32_t _x, int32_t _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Stride, 8);

struct Stride::Traits {
  using type = Stride;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Dilation FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;

 public:
  struct Traits;
  Dilation()
      : x_(0),
        y_(0) {
  }
  Dilation(int32_t _x, int32_t _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Dilation, 8);

struct Dilation::Traits {
  using type = Dilation;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) KernelShape FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t width_;
  int32_t height_;

 public:
  struct Traits;
  KernelShape()
      : width_(0),
        height_(0) {
  }
  KernelShape(int32_t _width, int32_t _height)
      : width_(flatbuffers::EndianScalar(_width)),
        height_(flatbuffers::EndianScalar(_height)) {
  }
  int32_t width() const {
    return flatbuffers::EndianScalar(width_);
  }
  int32_t height() const {
    return flatbuffers::EndianScalar(height_);
  }
};
FLATBUFFERS_STRUCT_END(KernelShape, 8);

struct KernelShape::Traits {
  using type = KernelShape;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Group FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t id_;

 public:
  struct Traits;
  Group()
      : id_(0) {
  }
  Group(int32_t _id)
      : id_(flatbuffers::EndianScalar(_id)) {
  }
  int32_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
};
FLATBUFFERS_STRUCT_END(Group, 4);

struct Group::Traits {
  using type = Group;
};

struct TensorInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DATA_FUSE = 6,
    VT_DIM = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  nn::FuseCode data_fuse() const {
    return static_cast<nn::FuseCode>(GetField<int8_t>(VT_DATA_FUSE, 0));
  }
  const flatbuffers::Vector<uint16_t> *dim() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_DIM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_DATA_FUSE, 1) &&
           VerifyOffset(verifier, VT_DIM) &&
           verifier.VerifyVector(dim()) &&
           verifier.EndTable();
  }
};

struct TensorInfoBuilder {
  typedef TensorInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TensorInfo::VT_NAME, name);
  }
  void add_data_fuse(nn::FuseCode data_fuse) {
    fbb_.AddElement<int8_t>(TensorInfo::VT_DATA_FUSE, static_cast<int8_t>(data_fuse), 0);
  }
  void add_dim(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> dim) {
    fbb_.AddOffset(TensorInfo::VT_DIM, dim);
  }
  explicit TensorInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorInfo> CreateTensorInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    nn::FuseCode data_fuse = nn::FuseCode::Relu,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> dim = 0) {
  TensorInfoBuilder builder_(_fbb);
  builder_.add_dim(dim);
  builder_.add_name(name);
  builder_.add_data_fuse(data_fuse);
  return builder_.Finish();
}

struct TensorInfo::Traits {
  using type = TensorInfo;
  static auto constexpr Create = CreateTensorInfo;
};

inline flatbuffers::Offset<TensorInfo> CreateTensorInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    nn::FuseCode data_fuse = nn::FuseCode::Relu,
    const std::vector<uint16_t> *dim = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto dim__ = dim ? _fbb.CreateVector<uint16_t>(*dim) : 0;
  return nn::CreateTensorInfo(
      _fbb,
      name__,
      data_fuse,
      dim__);
}

struct ubyteTensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ubyteTensorBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4,
    VT_DATA = 6
  };
  const nn::TensorInfo *info() const {
    return GetPointer<const nn::TensorInfo *>(VT_INFO);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct ubyteTensorBuilder {
  typedef ubyteTensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<nn::TensorInfo> info) {
    fbb_.AddOffset(ubyteTensor::VT_INFO, info);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(ubyteTensor::VT_DATA, data);
  }
  explicit ubyteTensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ubyteTensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ubyteTensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<ubyteTensor> CreateubyteTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  ubyteTensorBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_info(info);
  return builder_.Finish();
}

struct ubyteTensor::Traits {
  using type = ubyteTensor;
  static auto constexpr Create = CreateubyteTensor;
};

inline flatbuffers::Offset<ubyteTensor> CreateubyteTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return nn::CreateubyteTensor(
      _fbb,
      info,
      data__);
}

struct ushortTensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ushortTensorBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4,
    VT_DATA = 6
  };
  const nn::TensorInfo *info() const {
    return GetPointer<const nn::TensorInfo *>(VT_INFO);
  }
  const flatbuffers::Vector<uint16_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct ushortTensorBuilder {
  typedef ushortTensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<nn::TensorInfo> info) {
    fbb_.AddOffset(ushortTensor::VT_INFO, info);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> data) {
    fbb_.AddOffset(ushortTensor::VT_DATA, data);
  }
  explicit ushortTensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ushortTensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ushortTensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<ushortTensor> CreateushortTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> data = 0) {
  ushortTensorBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_info(info);
  return builder_.Finish();
}

struct ushortTensor::Traits {
  using type = ushortTensor;
  static auto constexpr Create = CreateushortTensor;
};

inline flatbuffers::Offset<ushortTensor> CreateushortTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    const std::vector<uint16_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint16_t>(*data) : 0;
  return nn::CreateushortTensor(
      _fbb,
      info,
      data__);
}

struct uintTensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef uintTensorBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4,
    VT_DATA = 6
  };
  const nn::TensorInfo *info() const {
    return GetPointer<const nn::TensorInfo *>(VT_INFO);
  }
  const flatbuffers::Vector<uint32_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct uintTensorBuilder {
  typedef uintTensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<nn::TensorInfo> info) {
    fbb_.AddOffset(uintTensor::VT_INFO, info);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data) {
    fbb_.AddOffset(uintTensor::VT_DATA, data);
  }
  explicit uintTensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<uintTensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<uintTensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<uintTensor> CreateuintTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data = 0) {
  uintTensorBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_info(info);
  return builder_.Finish();
}

struct uintTensor::Traits {
  using type = uintTensor;
  static auto constexpr Create = CreateuintTensor;
};

inline flatbuffers::Offset<uintTensor> CreateuintTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    const std::vector<uint32_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint32_t>(*data) : 0;
  return nn::CreateuintTensor(
      _fbb,
      info,
      data__);
}

struct intTensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef intTensorBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4,
    VT_DATA = 6
  };
  const nn::TensorInfo *info() const {
    return GetPointer<const nn::TensorInfo *>(VT_INFO);
  }
  const flatbuffers::Vector<int32_t> *data() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct intTensorBuilder {
  typedef intTensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<nn::TensorInfo> info) {
    fbb_.AddOffset(intTensor::VT_INFO, info);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<int32_t>> data) {
    fbb_.AddOffset(intTensor::VT_DATA, data);
  }
  explicit intTensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<intTensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<intTensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<intTensor> CreateintTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> data = 0) {
  intTensorBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_info(info);
  return builder_.Finish();
}

struct intTensor::Traits {
  using type = intTensor;
  static auto constexpr Create = CreateintTensor;
};

inline flatbuffers::Offset<intTensor> CreateintTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    const std::vector<int32_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<int32_t>(*data) : 0;
  return nn::CreateintTensor(
      _fbb,
      info,
      data__);
}

struct floatTensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef floatTensorBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4,
    VT_DATA = 6
  };
  const nn::TensorInfo *info() const {
    return GetPointer<const nn::TensorInfo *>(VT_INFO);
  }
  const flatbuffers::Vector<float> *data() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct floatTensorBuilder {
  typedef floatTensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<nn::TensorInfo> info) {
    fbb_.AddOffset(floatTensor::VT_INFO, info);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<float>> data) {
    fbb_.AddOffset(floatTensor::VT_DATA, data);
  }
  explicit floatTensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<floatTensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<floatTensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<floatTensor> CreatefloatTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> data = 0) {
  floatTensorBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_info(info);
  return builder_.Finish();
}

struct floatTensor::Traits {
  using type = floatTensor;
  static auto constexpr Create = CreatefloatTensor;
};

inline flatbuffers::Offset<floatTensor> CreatefloatTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    const std::vector<float> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<float>(*data) : 0;
  return nn::CreatefloatTensor(
      _fbb,
      info,
      data__);
}

struct doubleTensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef doubleTensorBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4,
    VT_DATA = 6
  };
  const nn::TensorInfo *info() const {
    return GetPointer<const nn::TensorInfo *>(VT_INFO);
  }
  const flatbuffers::Vector<double> *data() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct doubleTensorBuilder {
  typedef doubleTensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<nn::TensorInfo> info) {
    fbb_.AddOffset(doubleTensor::VT_INFO, info);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<double>> data) {
    fbb_.AddOffset(doubleTensor::VT_DATA, data);
  }
  explicit doubleTensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<doubleTensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<doubleTensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<doubleTensor> CreatedoubleTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> data = 0) {
  doubleTensorBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_info(info);
  return builder_.Finish();
}

struct doubleTensor::Traits {
  using type = doubleTensor;
  static auto constexpr Create = CreatedoubleTensor;
};

inline flatbuffers::Offset<doubleTensor> CreatedoubleTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::TensorInfo> info = 0,
    const std::vector<double> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<double>(*data) : 0;
  return nn::CreatedoubleTensor(
      _fbb,
      info,
      data__);
}

struct QuantInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuantInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_DIM = 8,
    VT_SCALES = 10,
    VT_ZERO_POINT = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  nn::DataType type() const {
    return static_cast<nn::DataType>(GetField<int8_t>(VT_TYPE, 0));
  }
  uint16_t dim() const {
    return GetField<uint16_t>(VT_DIM, 0);
  }
  const flatbuffers::Vector<float> *scales() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALES);
  }
  int32_t zero_point() const {
    return GetField<int32_t>(VT_ZERO_POINT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint16_t>(verifier, VT_DIM, 2) &&
           VerifyOffset(verifier, VT_SCALES) &&
           verifier.VerifyVector(scales()) &&
           VerifyField<int32_t>(verifier, VT_ZERO_POINT, 4) &&
           verifier.EndTable();
  }
};

struct QuantInfoBuilder {
  typedef QuantInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(QuantInfo::VT_NAME, name);
  }
  void add_type(nn::DataType type) {
    fbb_.AddElement<int8_t>(QuantInfo::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_dim(uint16_t dim) {
    fbb_.AddElement<uint16_t>(QuantInfo::VT_DIM, dim, 0);
  }
  void add_scales(flatbuffers::Offset<flatbuffers::Vector<float>> scales) {
    fbb_.AddOffset(QuantInfo::VT_SCALES, scales);
  }
  void add_zero_point(int32_t zero_point) {
    fbb_.AddElement<int32_t>(QuantInfo::VT_ZERO_POINT, zero_point, 0);
  }
  explicit QuantInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<QuantInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantInfo>(end);
    fbb_.Required(o, QuantInfo::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<QuantInfo> CreateQuantInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    nn::DataType type = nn::DataType::Float,
    uint16_t dim = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scales = 0,
    int32_t zero_point = 0) {
  QuantInfoBuilder builder_(_fbb);
  builder_.add_zero_point(zero_point);
  builder_.add_scales(scales);
  builder_.add_name(name);
  builder_.add_dim(dim);
  builder_.add_type(type);
  return builder_.Finish();
}

struct QuantInfo::Traits {
  using type = QuantInfo;
  static auto constexpr Create = CreateQuantInfo;
};

inline flatbuffers::Offset<QuantInfo> CreateQuantInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    nn::DataType type = nn::DataType::Float,
    uint16_t dim = 0,
    const std::vector<float> *scales = nullptr,
    int32_t zero_point = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto scales__ = scales ? _fbb.CreateVector<float>(*scales) : 0;
  return nn::CreateQuantInfo(
      _fbb,
      name__,
      type,
      dim,
      scales__,
      zero_point);
}

struct Input FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InputBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DIM = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<uint16_t> *dim() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_DIM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DIM) &&
           verifier.VerifyVector(dim()) &&
           verifier.EndTable();
  }
};

struct InputBuilder {
  typedef Input Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Input::VT_NAME, name);
  }
  void add_dim(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> dim) {
    fbb_.AddOffset(Input::VT_DIM, dim);
  }
  explicit InputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Input> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Input>(end);
    return o;
  }
};

inline flatbuffers::Offset<Input> CreateInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> dim = 0) {
  InputBuilder builder_(_fbb);
  builder_.add_dim(dim);
  builder_.add_name(name);
  return builder_.Finish();
}

struct Input::Traits {
  using type = Input;
  static auto constexpr Create = CreateInput;
};

inline flatbuffers::Offset<Input> CreateInputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<uint16_t> *dim = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto dim__ = dim ? _fbb.CreateVector<uint16_t>(*dim) : 0;
  return nn::CreateInput(
      _fbb,
      name__,
      dim__);
}

struct LinkOd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LinkOdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_OUTPUT = 6,
    VT_NAME = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *input() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_INPUT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *output() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_OUTPUT);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_INPUT) &&
           verifier.VerifyVector(input()) &&
           verifier.VerifyVectorOfStrings(input()) &&
           VerifyOffsetRequired(verifier, VT_OUTPUT) &&
           verifier.VerifyVector(output()) &&
           verifier.VerifyVectorOfStrings(output()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct LinkOdBuilder {
  typedef LinkOd Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> input) {
    fbb_.AddOffset(LinkOd::VT_INPUT, input);
  }
  void add_output(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> output) {
    fbb_.AddOffset(LinkOd::VT_OUTPUT, output);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(LinkOd::VT_NAME, name);
  }
  explicit LinkOdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LinkOd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LinkOd>(end);
    fbb_.Required(o, LinkOd::VT_INPUT);
    fbb_.Required(o, LinkOd::VT_OUTPUT);
    return o;
  }
};

inline flatbuffers::Offset<LinkOd> CreateLinkOd(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> input = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> output = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  LinkOdBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_output(output);
  builder_.add_input(input);
  return builder_.Finish();
}

struct LinkOd::Traits {
  using type = LinkOd;
  static auto constexpr Create = CreateLinkOd;
};

inline flatbuffers::Offset<LinkOd> CreateLinkOdDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *input = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *output = nullptr,
    const char *name = nullptr) {
  auto input__ = input ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*input) : 0;
  auto output__ = output ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*output) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return nn::CreateLinkOd(
      _fbb,
      input__,
      output__,
      name__);
}

struct Link FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LinkBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_OUTPUT = 6,
    VT_NAME = 8
  };
  const flatbuffers::Vector<uint32_t> *input() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INPUT);
  }
  const flatbuffers::Vector<uint32_t> *output() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_OUTPUT);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyVector(input()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyVector(output()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct LinkBuilder {
  typedef Link Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> input) {
    fbb_.AddOffset(Link::VT_INPUT, input);
  }
  void add_output(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> output) {
    fbb_.AddOffset(Link::VT_OUTPUT, output);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Link::VT_NAME, name);
  }
  explicit LinkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Link> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Link>(end);
    return o;
  }
};

inline flatbuffers::Offset<Link> CreateLink(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> input = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> output = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  LinkBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_output(output);
  builder_.add_input(input);
  return builder_.Finish();
}

struct Link::Traits {
  using type = Link;
  static auto constexpr Create = CreateLink;
};

inline flatbuffers::Offset<Link> CreateLinkDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *input = nullptr,
    const std::vector<uint32_t> *output = nullptr,
    const char *name = nullptr) {
  auto input__ = input ? _fbb.CreateVector<uint32_t>(*input) : 0;
  auto output__ = output ? _fbb.CreateVector<uint32_t>(*output) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return nn::CreateLink(
      _fbb,
      input__,
      output__,
      name__);
}

struct CONV_2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CONV_2DBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_PADDING = 6,
    VT_STRIDE = 8,
    VT_DILATION = 10,
    VT_GROUP = 12,
    VT_FUSE_CODE = 14
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const nn::Pads *padding() const {
    return GetStruct<const nn::Pads *>(VT_PADDING);
  }
  const nn::Stride *stride() const {
    return GetStruct<const nn::Stride *>(VT_STRIDE);
  }
  const nn::Dilation *dilation() const {
    return GetStruct<const nn::Dilation *>(VT_DILATION);
  }
  const nn::Group *group() const {
    return GetStruct<const nn::Group *>(VT_GROUP);
  }
  nn::FuseCode fuse_code() const {
    return static_cast<nn::FuseCode>(GetField<int8_t>(VT_FUSE_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<nn::Pads>(verifier, VT_PADDING, 4) &&
           VerifyField<nn::Stride>(verifier, VT_STRIDE, 4) &&
           VerifyField<nn::Dilation>(verifier, VT_DILATION, 4) &&
           VerifyField<nn::Group>(verifier, VT_GROUP, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSE_CODE, 1) &&
           verifier.EndTable();
  }
};

struct CONV_2DBuilder {
  typedef CONV_2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(CONV_2D::VT_LINK, link);
  }
  void add_padding(const nn::Pads *padding) {
    fbb_.AddStruct(CONV_2D::VT_PADDING, padding);
  }
  void add_stride(const nn::Stride *stride) {
    fbb_.AddStruct(CONV_2D::VT_STRIDE, stride);
  }
  void add_dilation(const nn::Dilation *dilation) {
    fbb_.AddStruct(CONV_2D::VT_DILATION, dilation);
  }
  void add_group(const nn::Group *group) {
    fbb_.AddStruct(CONV_2D::VT_GROUP, group);
  }
  void add_fuse_code(nn::FuseCode fuse_code) {
    fbb_.AddElement<int8_t>(CONV_2D::VT_FUSE_CODE, static_cast<int8_t>(fuse_code), 0);
  }
  explicit CONV_2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CONV_2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CONV_2D>(end);
    fbb_.Required(o, CONV_2D::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<CONV_2D> CreateCONV_2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const nn::Pads *padding = nullptr,
    const nn::Stride *stride = nullptr,
    const nn::Dilation *dilation = nullptr,
    const nn::Group *group = nullptr,
    nn::FuseCode fuse_code = nn::FuseCode::Relu) {
  CONV_2DBuilder builder_(_fbb);
  builder_.add_group(group);
  builder_.add_dilation(dilation);
  builder_.add_stride(stride);
  builder_.add_padding(padding);
  builder_.add_link(link);
  builder_.add_fuse_code(fuse_code);
  return builder_.Finish();
}

struct CONV_2D::Traits {
  using type = CONV_2D;
  static auto constexpr Create = CreateCONV_2D;
};

struct AVERAGE_POOL_2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AVERAGE_POOL_2DBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_PADDING = 6,
    VT_STRIDE = 8,
    VT_KERNEL_SHAPE = 10,
    VT_FUSE_CODE = 12
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const nn::Pads *padding() const {
    return GetStruct<const nn::Pads *>(VT_PADDING);
  }
  const nn::Stride *stride() const {
    return GetStruct<const nn::Stride *>(VT_STRIDE);
  }
  const nn::KernelShape *kernel_shape() const {
    return GetStruct<const nn::KernelShape *>(VT_KERNEL_SHAPE);
  }
  nn::FuseCode fuse_code() const {
    return static_cast<nn::FuseCode>(GetField<int8_t>(VT_FUSE_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<nn::Pads>(verifier, VT_PADDING, 4) &&
           VerifyField<nn::Stride>(verifier, VT_STRIDE, 4) &&
           VerifyField<nn::KernelShape>(verifier, VT_KERNEL_SHAPE, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSE_CODE, 1) &&
           verifier.EndTable();
  }
};

struct AVERAGE_POOL_2DBuilder {
  typedef AVERAGE_POOL_2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(AVERAGE_POOL_2D::VT_LINK, link);
  }
  void add_padding(const nn::Pads *padding) {
    fbb_.AddStruct(AVERAGE_POOL_2D::VT_PADDING, padding);
  }
  void add_stride(const nn::Stride *stride) {
    fbb_.AddStruct(AVERAGE_POOL_2D::VT_STRIDE, stride);
  }
  void add_kernel_shape(const nn::KernelShape *kernel_shape) {
    fbb_.AddStruct(AVERAGE_POOL_2D::VT_KERNEL_SHAPE, kernel_shape);
  }
  void add_fuse_code(nn::FuseCode fuse_code) {
    fbb_.AddElement<int8_t>(AVERAGE_POOL_2D::VT_FUSE_CODE, static_cast<int8_t>(fuse_code), 0);
  }
  explicit AVERAGE_POOL_2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AVERAGE_POOL_2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AVERAGE_POOL_2D>(end);
    fbb_.Required(o, AVERAGE_POOL_2D::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<AVERAGE_POOL_2D> CreateAVERAGE_POOL_2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const nn::Pads *padding = nullptr,
    const nn::Stride *stride = nullptr,
    const nn::KernelShape *kernel_shape = nullptr,
    nn::FuseCode fuse_code = nn::FuseCode::Relu) {
  AVERAGE_POOL_2DBuilder builder_(_fbb);
  builder_.add_kernel_shape(kernel_shape);
  builder_.add_stride(stride);
  builder_.add_padding(padding);
  builder_.add_link(link);
  builder_.add_fuse_code(fuse_code);
  return builder_.Finish();
}

struct AVERAGE_POOL_2D::Traits {
  using type = AVERAGE_POOL_2D;
  static auto constexpr Create = CreateAVERAGE_POOL_2D;
};

struct MAX_POOL_2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MAX_POOL_2DBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_PADDING = 6,
    VT_STRIDE = 8,
    VT_KERNEL_SHAPE = 10,
    VT_FUSE_CODE = 12
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const nn::Pads *padding() const {
    return GetStruct<const nn::Pads *>(VT_PADDING);
  }
  const nn::Stride *stride() const {
    return GetStruct<const nn::Stride *>(VT_STRIDE);
  }
  const nn::KernelShape *kernel_shape() const {
    return GetStruct<const nn::KernelShape *>(VT_KERNEL_SHAPE);
  }
  nn::FuseCode fuse_code() const {
    return static_cast<nn::FuseCode>(GetField<int8_t>(VT_FUSE_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<nn::Pads>(verifier, VT_PADDING, 4) &&
           VerifyField<nn::Stride>(verifier, VT_STRIDE, 4) &&
           VerifyField<nn::KernelShape>(verifier, VT_KERNEL_SHAPE, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSE_CODE, 1) &&
           verifier.EndTable();
  }
};

struct MAX_POOL_2DBuilder {
  typedef MAX_POOL_2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(MAX_POOL_2D::VT_LINK, link);
  }
  void add_padding(const nn::Pads *padding) {
    fbb_.AddStruct(MAX_POOL_2D::VT_PADDING, padding);
  }
  void add_stride(const nn::Stride *stride) {
    fbb_.AddStruct(MAX_POOL_2D::VT_STRIDE, stride);
  }
  void add_kernel_shape(const nn::KernelShape *kernel_shape) {
    fbb_.AddStruct(MAX_POOL_2D::VT_KERNEL_SHAPE, kernel_shape);
  }
  void add_fuse_code(nn::FuseCode fuse_code) {
    fbb_.AddElement<int8_t>(MAX_POOL_2D::VT_FUSE_CODE, static_cast<int8_t>(fuse_code), 0);
  }
  explicit MAX_POOL_2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MAX_POOL_2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MAX_POOL_2D>(end);
    fbb_.Required(o, MAX_POOL_2D::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<MAX_POOL_2D> CreateMAX_POOL_2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const nn::Pads *padding = nullptr,
    const nn::Stride *stride = nullptr,
    const nn::KernelShape *kernel_shape = nullptr,
    nn::FuseCode fuse_code = nn::FuseCode::Relu) {
  MAX_POOL_2DBuilder builder_(_fbb);
  builder_.add_kernel_shape(kernel_shape);
  builder_.add_stride(stride);
  builder_.add_padding(padding);
  builder_.add_link(link);
  builder_.add_fuse_code(fuse_code);
  return builder_.Finish();
}

struct MAX_POOL_2D::Traits {
  using type = MAX_POOL_2D;
  static auto constexpr Create = CreateMAX_POOL_2D;
};

struct RELU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RELUBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct RELUBuilder {
  typedef RELU Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(RELU::VT_LINK, link);
  }
  explicit RELUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RELU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RELU>(end);
    fbb_.Required(o, RELU::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<RELU> CreateRELU(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  RELUBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct RELU::Traits {
  using type = RELU;
  static auto constexpr Create = CreateRELU;
};

struct SOFTMAX FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SOFTMAXBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_BETA = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<float>(verifier, VT_BETA, 4) &&
           verifier.EndTable();
  }
};

struct SOFTMAXBuilder {
  typedef SOFTMAX Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(SOFTMAX::VT_LINK, link);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(SOFTMAX::VT_BETA, beta, 0.0f);
  }
  explicit SOFTMAXBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SOFTMAX> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SOFTMAX>(end);
    fbb_.Required(o, SOFTMAX::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<SOFTMAX> CreateSOFTMAX(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    float beta = 0.0f) {
  SOFTMAXBuilder builder_(_fbb);
  builder_.add_beta(beta);
  builder_.add_link(link);
  return builder_.Finish();
}

struct SOFTMAX::Traits {
  using type = SOFTMAX;
  static auto constexpr Create = CreateSOFTMAX;
};

struct FULLY_CONNECTED FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FULLY_CONNECTEDBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_BIAS = 6,
    VT_FUSE_CODE = 8
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  float bias() const {
    return GetField<float>(VT_BIAS, 0.0f);
  }
  nn::FuseCode fuse_code() const {
    return static_cast<nn::FuseCode>(GetField<int8_t>(VT_FUSE_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<float>(verifier, VT_BIAS, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSE_CODE, 1) &&
           verifier.EndTable();
  }
};

struct FULLY_CONNECTEDBuilder {
  typedef FULLY_CONNECTED Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(FULLY_CONNECTED::VT_LINK, link);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(FULLY_CONNECTED::VT_BIAS, bias, 0.0f);
  }
  void add_fuse_code(nn::FuseCode fuse_code) {
    fbb_.AddElement<int8_t>(FULLY_CONNECTED::VT_FUSE_CODE, static_cast<int8_t>(fuse_code), 0);
  }
  explicit FULLY_CONNECTEDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FULLY_CONNECTED> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FULLY_CONNECTED>(end);
    fbb_.Required(o, FULLY_CONNECTED::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<FULLY_CONNECTED> CreateFULLY_CONNECTED(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    float bias = 0.0f,
    nn::FuseCode fuse_code = nn::FuseCode::Relu) {
  FULLY_CONNECTEDBuilder builder_(_fbb);
  builder_.add_bias(bias);
  builder_.add_link(link);
  builder_.add_fuse_code(fuse_code);
  return builder_.Finish();
}

struct FULLY_CONNECTED::Traits {
  using type = FULLY_CONNECTED;
  static auto constexpr Create = CreateFULLY_CONNECTED;
};

struct ADD FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ADDBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_FUSE_CODE = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  nn::FuseCode fuse_code() const {
    return static_cast<nn::FuseCode>(GetField<int8_t>(VT_FUSE_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<int8_t>(verifier, VT_FUSE_CODE, 1) &&
           verifier.EndTable();
  }
};

struct ADDBuilder {
  typedef ADD Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(ADD::VT_LINK, link);
  }
  void add_fuse_code(nn::FuseCode fuse_code) {
    fbb_.AddElement<int8_t>(ADD::VT_FUSE_CODE, static_cast<int8_t>(fuse_code), 0);
  }
  explicit ADDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ADD> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ADD>(end);
    fbb_.Required(o, ADD::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<ADD> CreateADD(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    nn::FuseCode fuse_code = nn::FuseCode::Relu) {
  ADDBuilder builder_(_fbb);
  builder_.add_link(link);
  builder_.add_fuse_code(fuse_code);
  return builder_.Finish();
}

struct ADD::Traits {
  using type = ADD;
  static auto constexpr Create = CreateADD;
};

struct SUB FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SUBBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_FUSE_CODE = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  nn::FuseCode fuse_code() const {
    return static_cast<nn::FuseCode>(GetField<int8_t>(VT_FUSE_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<int8_t>(verifier, VT_FUSE_CODE, 1) &&
           verifier.EndTable();
  }
};

struct SUBBuilder {
  typedef SUB Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(SUB::VT_LINK, link);
  }
  void add_fuse_code(nn::FuseCode fuse_code) {
    fbb_.AddElement<int8_t>(SUB::VT_FUSE_CODE, static_cast<int8_t>(fuse_code), 0);
  }
  explicit SUBBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SUB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SUB>(end);
    fbb_.Required(o, SUB::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<SUB> CreateSUB(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    nn::FuseCode fuse_code = nn::FuseCode::Relu) {
  SUBBuilder builder_(_fbb);
  builder_.add_link(link);
  builder_.add_fuse_code(fuse_code);
  return builder_.Finish();
}

struct SUB::Traits {
  using type = SUB;
  static auto constexpr Create = CreateSUB;
};

struct MUL FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MULBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_FUSE_CODE = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  nn::FuseCode fuse_code() const {
    return static_cast<nn::FuseCode>(GetField<int8_t>(VT_FUSE_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<int8_t>(verifier, VT_FUSE_CODE, 1) &&
           verifier.EndTable();
  }
};

struct MULBuilder {
  typedef MUL Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(MUL::VT_LINK, link);
  }
  void add_fuse_code(nn::FuseCode fuse_code) {
    fbb_.AddElement<int8_t>(MUL::VT_FUSE_CODE, static_cast<int8_t>(fuse_code), 0);
  }
  explicit MULBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MUL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MUL>(end);
    fbb_.Required(o, MUL::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<MUL> CreateMUL(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    nn::FuseCode fuse_code = nn::FuseCode::Relu) {
  MULBuilder builder_(_fbb);
  builder_.add_link(link);
  builder_.add_fuse_code(fuse_code);
  return builder_.Finish();
}

struct MUL::Traits {
  using type = MUL;
  static auto constexpr Create = CreateMUL;
};

struct CONCATENATION FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CONCATENATIONBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_AXIS = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
};

struct CONCATENATIONBuilder {
  typedef CONCATENATION Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(CONCATENATION::VT_LINK, link);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(CONCATENATION::VT_AXIS, axis, 0);
  }
  explicit CONCATENATIONBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CONCATENATION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CONCATENATION>(end);
    fbb_.Required(o, CONCATENATION::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<CONCATENATION> CreateCONCATENATION(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    int32_t axis = 0) {
  CONCATENATIONBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_link(link);
  return builder_.Finish();
}

struct CONCATENATION::Traits {
  using type = CONCATENATION;
  static auto constexpr Create = CreateCONCATENATION;
};

struct DEPTHWISE_CONV_2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DEPTHWISE_CONV_2DBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_PADDING = 6,
    VT_STRIDE = 8,
    VT_DEPTH_MULTIPLIER = 10,
    VT_FUSE_CODE = 12
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const nn::Pads *padding() const {
    return GetStruct<const nn::Pads *>(VT_PADDING);
  }
  const nn::Stride *stride() const {
    return GetStruct<const nn::Stride *>(VT_STRIDE);
  }
  int32_t depth_multiplier() const {
    return GetField<int32_t>(VT_DEPTH_MULTIPLIER, 0);
  }
  nn::FuseCode fuse_code() const {
    return static_cast<nn::FuseCode>(GetField<int8_t>(VT_FUSE_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<nn::Pads>(verifier, VT_PADDING, 4) &&
           VerifyField<nn::Stride>(verifier, VT_STRIDE, 4) &&
           VerifyField<int32_t>(verifier, VT_DEPTH_MULTIPLIER, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSE_CODE, 1) &&
           verifier.EndTable();
  }
};

struct DEPTHWISE_CONV_2DBuilder {
  typedef DEPTHWISE_CONV_2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(DEPTHWISE_CONV_2D::VT_LINK, link);
  }
  void add_padding(const nn::Pads *padding) {
    fbb_.AddStruct(DEPTHWISE_CONV_2D::VT_PADDING, padding);
  }
  void add_stride(const nn::Stride *stride) {
    fbb_.AddStruct(DEPTHWISE_CONV_2D::VT_STRIDE, stride);
  }
  void add_depth_multiplier(int32_t depth_multiplier) {
    fbb_.AddElement<int32_t>(DEPTHWISE_CONV_2D::VT_DEPTH_MULTIPLIER, depth_multiplier, 0);
  }
  void add_fuse_code(nn::FuseCode fuse_code) {
    fbb_.AddElement<int8_t>(DEPTHWISE_CONV_2D::VT_FUSE_CODE, static_cast<int8_t>(fuse_code), 0);
  }
  explicit DEPTHWISE_CONV_2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DEPTHWISE_CONV_2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DEPTHWISE_CONV_2D>(end);
    fbb_.Required(o, DEPTHWISE_CONV_2D::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<DEPTHWISE_CONV_2D> CreateDEPTHWISE_CONV_2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const nn::Pads *padding = nullptr,
    const nn::Stride *stride = nullptr,
    int32_t depth_multiplier = 0,
    nn::FuseCode fuse_code = nn::FuseCode::Relu) {
  DEPTHWISE_CONV_2DBuilder builder_(_fbb);
  builder_.add_depth_multiplier(depth_multiplier);
  builder_.add_stride(stride);
  builder_.add_padding(padding);
  builder_.add_link(link);
  builder_.add_fuse_code(fuse_code);
  return builder_.Finish();
}

struct DEPTHWISE_CONV_2D::Traits {
  using type = DEPTHWISE_CONV_2D;
  static auto constexpr Create = CreateDEPTHWISE_CONV_2D;
};

struct BATCH_TO_SPACE_ND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BATCH_TO_SPACE_NDBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_BLOCK_SIZES = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const flatbuffers::Vector<int32_t> *block_sizes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCK_SIZES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyOffset(verifier, VT_BLOCK_SIZES) &&
           verifier.VerifyVector(block_sizes()) &&
           verifier.EndTable();
  }
};

struct BATCH_TO_SPACE_NDBuilder {
  typedef BATCH_TO_SPACE_ND Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(BATCH_TO_SPACE_ND::VT_LINK, link);
  }
  void add_block_sizes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_sizes) {
    fbb_.AddOffset(BATCH_TO_SPACE_ND::VT_BLOCK_SIZES, block_sizes);
  }
  explicit BATCH_TO_SPACE_NDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BATCH_TO_SPACE_ND> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BATCH_TO_SPACE_ND>(end);
    fbb_.Required(o, BATCH_TO_SPACE_ND::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<BATCH_TO_SPACE_ND> CreateBATCH_TO_SPACE_ND(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_sizes = 0) {
  BATCH_TO_SPACE_NDBuilder builder_(_fbb);
  builder_.add_block_sizes(block_sizes);
  builder_.add_link(link);
  return builder_.Finish();
}

struct BATCH_TO_SPACE_ND::Traits {
  using type = BATCH_TO_SPACE_ND;
  static auto constexpr Create = CreateBATCH_TO_SPACE_ND;
};

inline flatbuffers::Offset<BATCH_TO_SPACE_ND> CreateBATCH_TO_SPACE_NDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const std::vector<int32_t> *block_sizes = nullptr) {
  auto block_sizes__ = block_sizes ? _fbb.CreateVector<int32_t>(*block_sizes) : 0;
  return nn::CreateBATCH_TO_SPACE_ND(
      _fbb,
      link,
      block_sizes__);
}

struct SPACE_TO_BATCH_ND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SPACE_TO_BATCH_NDBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_BLOCK_SIZES = 6,
    VT_PADDING = 8
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const flatbuffers::Vector<int32_t> *block_sizes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCK_SIZES);
  }
  const nn::Pads *padding() const {
    return GetStruct<const nn::Pads *>(VT_PADDING);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyOffset(verifier, VT_BLOCK_SIZES) &&
           verifier.VerifyVector(block_sizes()) &&
           VerifyField<nn::Pads>(verifier, VT_PADDING, 4) &&
           verifier.EndTable();
  }
};

struct SPACE_TO_BATCH_NDBuilder {
  typedef SPACE_TO_BATCH_ND Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(SPACE_TO_BATCH_ND::VT_LINK, link);
  }
  void add_block_sizes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_sizes) {
    fbb_.AddOffset(SPACE_TO_BATCH_ND::VT_BLOCK_SIZES, block_sizes);
  }
  void add_padding(const nn::Pads *padding) {
    fbb_.AddStruct(SPACE_TO_BATCH_ND::VT_PADDING, padding);
  }
  explicit SPACE_TO_BATCH_NDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SPACE_TO_BATCH_ND> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SPACE_TO_BATCH_ND>(end);
    fbb_.Required(o, SPACE_TO_BATCH_ND::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<SPACE_TO_BATCH_ND> CreateSPACE_TO_BATCH_ND(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_sizes = 0,
    const nn::Pads *padding = nullptr) {
  SPACE_TO_BATCH_NDBuilder builder_(_fbb);
  builder_.add_padding(padding);
  builder_.add_block_sizes(block_sizes);
  builder_.add_link(link);
  return builder_.Finish();
}

struct SPACE_TO_BATCH_ND::Traits {
  using type = SPACE_TO_BATCH_ND;
  static auto constexpr Create = CreateSPACE_TO_BATCH_ND;
};

inline flatbuffers::Offset<SPACE_TO_BATCH_ND> CreateSPACE_TO_BATCH_NDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const std::vector<int32_t> *block_sizes = nullptr,
    const nn::Pads *padding = nullptr) {
  auto block_sizes__ = block_sizes ? _fbb.CreateVector<int32_t>(*block_sizes) : 0;
  return nn::CreateSPACE_TO_BATCH_ND(
      _fbb,
      link,
      block_sizes__,
      padding);
}

struct STRIDED_SLICE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef STRIDED_SLICEBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_STARTS = 6,
    VT_ENDS = 8,
    VT_STRIDES = 10,
    VT_BEGIN_MASK = 12,
    VT_END_MASK = 14,
    VT_SHRINK_AXIS_MASK = 16
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const flatbuffers::Vector<int32_t> *starts() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STARTS);
  }
  const flatbuffers::Vector<int32_t> *ends() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ENDS);
  }
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  int32_t begin_mask() const {
    return GetField<int32_t>(VT_BEGIN_MASK, 0);
  }
  int32_t end_mask() const {
    return GetField<int32_t>(VT_END_MASK, 0);
  }
  int32_t shrink_axis_mask() const {
    return GetField<int32_t>(VT_SHRINK_AXIS_MASK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyOffset(verifier, VT_STARTS) &&
           verifier.VerifyVector(starts()) &&
           VerifyOffset(verifier, VT_ENDS) &&
           verifier.VerifyVector(ends()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyField<int32_t>(verifier, VT_BEGIN_MASK, 4) &&
           VerifyField<int32_t>(verifier, VT_END_MASK, 4) &&
           VerifyField<int32_t>(verifier, VT_SHRINK_AXIS_MASK, 4) &&
           verifier.EndTable();
  }
};

struct STRIDED_SLICEBuilder {
  typedef STRIDED_SLICE Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(STRIDED_SLICE::VT_LINK, link);
  }
  void add_starts(flatbuffers::Offset<flatbuffers::Vector<int32_t>> starts) {
    fbb_.AddOffset(STRIDED_SLICE::VT_STARTS, starts);
  }
  void add_ends(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ends) {
    fbb_.AddOffset(STRIDED_SLICE::VT_ENDS, ends);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(STRIDED_SLICE::VT_STRIDES, strides);
  }
  void add_begin_mask(int32_t begin_mask) {
    fbb_.AddElement<int32_t>(STRIDED_SLICE::VT_BEGIN_MASK, begin_mask, 0);
  }
  void add_end_mask(int32_t end_mask) {
    fbb_.AddElement<int32_t>(STRIDED_SLICE::VT_END_MASK, end_mask, 0);
  }
  void add_shrink_axis_mask(int32_t shrink_axis_mask) {
    fbb_.AddElement<int32_t>(STRIDED_SLICE::VT_SHRINK_AXIS_MASK, shrink_axis_mask, 0);
  }
  explicit STRIDED_SLICEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<STRIDED_SLICE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<STRIDED_SLICE>(end);
    fbb_.Required(o, STRIDED_SLICE::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<STRIDED_SLICE> CreateSTRIDED_SLICE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> starts = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ends = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0,
    int32_t begin_mask = 0,
    int32_t end_mask = 0,
    int32_t shrink_axis_mask = 0) {
  STRIDED_SLICEBuilder builder_(_fbb);
  builder_.add_shrink_axis_mask(shrink_axis_mask);
  builder_.add_end_mask(end_mask);
  builder_.add_begin_mask(begin_mask);
  builder_.add_strides(strides);
  builder_.add_ends(ends);
  builder_.add_starts(starts);
  builder_.add_link(link);
  return builder_.Finish();
}

struct STRIDED_SLICE::Traits {
  using type = STRIDED_SLICE;
  static auto constexpr Create = CreateSTRIDED_SLICE;
};

inline flatbuffers::Offset<STRIDED_SLICE> CreateSTRIDED_SLICEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const std::vector<int32_t> *starts = nullptr,
    const std::vector<int32_t> *ends = nullptr,
    const std::vector<int32_t> *strides = nullptr,
    int32_t begin_mask = 0,
    int32_t end_mask = 0,
    int32_t shrink_axis_mask = 0) {
  auto starts__ = starts ? _fbb.CreateVector<int32_t>(*starts) : 0;
  auto ends__ = ends ? _fbb.CreateVector<int32_t>(*ends) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  return nn::CreateSTRIDED_SLICE(
      _fbb,
      link,
      starts__,
      ends__,
      strides__,
      begin_mask,
      end_mask,
      shrink_axis_mask);
}

struct DEQUANTIZE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DEQUANTIZEBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct DEQUANTIZEBuilder {
  typedef DEQUANTIZE Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(DEQUANTIZE::VT_LINK, link);
  }
  explicit DEQUANTIZEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DEQUANTIZE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DEQUANTIZE>(end);
    fbb_.Required(o, DEQUANTIZE::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<DEQUANTIZE> CreateDEQUANTIZE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  DEQUANTIZEBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct DEQUANTIZE::Traits {
  using type = DEQUANTIZE;
  static auto constexpr Create = CreateDEQUANTIZE;
};

struct LOCAL_RESPONSE_NORMALIZATION FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LOCAL_RESPONSE_NORMALIZATIONBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_RADIUS = 6,
    VT_BIAS = 8,
    VT_ALPHA = 10,
    VT_BETA = 12
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  int32_t radius() const {
    return GetField<int32_t>(VT_RADIUS, 0);
  }
  float bias() const {
    return GetField<float>(VT_BIAS, 0.0f);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<int32_t>(verifier, VT_RADIUS, 4) &&
           VerifyField<float>(verifier, VT_BIAS, 4) &&
           VerifyField<float>(verifier, VT_ALPHA, 4) &&
           VerifyField<float>(verifier, VT_BETA, 4) &&
           verifier.EndTable();
  }
};

struct LOCAL_RESPONSE_NORMALIZATIONBuilder {
  typedef LOCAL_RESPONSE_NORMALIZATION Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(LOCAL_RESPONSE_NORMALIZATION::VT_LINK, link);
  }
  void add_radius(int32_t radius) {
    fbb_.AddElement<int32_t>(LOCAL_RESPONSE_NORMALIZATION::VT_RADIUS, radius, 0);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(LOCAL_RESPONSE_NORMALIZATION::VT_BIAS, bias, 0.0f);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LOCAL_RESPONSE_NORMALIZATION::VT_ALPHA, alpha, 0.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(LOCAL_RESPONSE_NORMALIZATION::VT_BETA, beta, 0.0f);
  }
  explicit LOCAL_RESPONSE_NORMALIZATIONBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LOCAL_RESPONSE_NORMALIZATION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LOCAL_RESPONSE_NORMALIZATION>(end);
    fbb_.Required(o, LOCAL_RESPONSE_NORMALIZATION::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<LOCAL_RESPONSE_NORMALIZATION> CreateLOCAL_RESPONSE_NORMALIZATION(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    int32_t radius = 0,
    float bias = 0.0f,
    float alpha = 0.0f,
    float beta = 0.0f) {
  LOCAL_RESPONSE_NORMALIZATIONBuilder builder_(_fbb);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_bias(bias);
  builder_.add_radius(radius);
  builder_.add_link(link);
  return builder_.Finish();
}

struct LOCAL_RESPONSE_NORMALIZATION::Traits {
  using type = LOCAL_RESPONSE_NORMALIZATION;
  static auto constexpr Create = CreateLOCAL_RESPONSE_NORMALIZATION;
};

struct TANH FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TANHBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct TANHBuilder {
  typedef TANH Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(TANH::VT_LINK, link);
  }
  explicit TANHBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TANH> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TANH>(end);
    fbb_.Required(o, TANH::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<TANH> CreateTANH(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  TANHBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct TANH::Traits {
  using type = TANH;
  static auto constexpr Create = CreateTANH;
};

struct FLOOR FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FLOORBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct FLOORBuilder {
  typedef FLOOR Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(FLOOR::VT_LINK, link);
  }
  explicit FLOORBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FLOOR> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FLOOR>(end);
    fbb_.Required(o, FLOOR::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<FLOOR> CreateFLOOR(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  FLOORBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct FLOOR::Traits {
  using type = FLOOR;
  static auto constexpr Create = CreateFLOOR;
};

struct LOGISTIC FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LOGISTICBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct LOGISTICBuilder {
  typedef LOGISTIC Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(LOGISTIC::VT_LINK, link);
  }
  explicit LOGISTICBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LOGISTIC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LOGISTIC>(end);
    fbb_.Required(o, LOGISTIC::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<LOGISTIC> CreateLOGISTIC(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  LOGISTICBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct LOGISTIC::Traits {
  using type = LOGISTIC;
  static auto constexpr Create = CreateLOGISTIC;
};

struct PRELU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PRELUBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_ALPHA = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const flatbuffers::String *alpha() const {
    return GetPointer<const flatbuffers::String *>(VT_ALPHA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyOffset(verifier, VT_ALPHA) &&
           verifier.VerifyString(alpha()) &&
           verifier.EndTable();
  }
};

struct PRELUBuilder {
  typedef PRELU Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(PRELU::VT_LINK, link);
  }
  void add_alpha(flatbuffers::Offset<flatbuffers::String> alpha) {
    fbb_.AddOffset(PRELU::VT_ALPHA, alpha);
  }
  explicit PRELUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PRELU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PRELU>(end);
    fbb_.Required(o, PRELU::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<PRELU> CreatePRELU(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    flatbuffers::Offset<flatbuffers::String> alpha = 0) {
  PRELUBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  builder_.add_link(link);
  return builder_.Finish();
}

struct PRELU::Traits {
  using type = PRELU;
  static auto constexpr Create = CreatePRELU;
};

inline flatbuffers::Offset<PRELU> CreatePRELUDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const char *alpha = nullptr) {
  auto alpha__ = alpha ? _fbb.CreateString(alpha) : 0;
  return nn::CreatePRELU(
      _fbb,
      link,
      alpha__);
}

struct POW FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef POWBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_EXP = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const flatbuffers::String *exp() const {
    return GetPointer<const flatbuffers::String *>(VT_EXP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyOffset(verifier, VT_EXP) &&
           verifier.VerifyString(exp()) &&
           verifier.EndTable();
  }
};

struct POWBuilder {
  typedef POW Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(POW::VT_LINK, link);
  }
  void add_exp(flatbuffers::Offset<flatbuffers::String> exp) {
    fbb_.AddOffset(POW::VT_EXP, exp);
  }
  explicit POWBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<POW> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<POW>(end);
    fbb_.Required(o, POW::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<POW> CreatePOW(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    flatbuffers::Offset<flatbuffers::String> exp = 0) {
  POWBuilder builder_(_fbb);
  builder_.add_exp(exp);
  builder_.add_link(link);
  return builder_.Finish();
}

struct POW::Traits {
  using type = POW;
  static auto constexpr Create = CreatePOW;
};

inline flatbuffers::Offset<POW> CreatePOWDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const char *exp = nullptr) {
  auto exp__ = exp ? _fbb.CreateString(exp) : 0;
  return nn::CreatePOW(
      _fbb,
      link,
      exp__);
}

struct NEG FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NEGBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct NEGBuilder {
  typedef NEG Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(NEG::VT_LINK, link);
  }
  explicit NEGBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NEG> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NEG>(end);
    fbb_.Required(o, NEG::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<NEG> CreateNEG(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  NEGBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct NEG::Traits {
  using type = NEG;
  static auto constexpr Create = CreateNEG;
};

struct MINIMUM FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MINIMUMBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct MINIMUMBuilder {
  typedef MINIMUM Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(MINIMUM::VT_LINK, link);
  }
  explicit MINIMUMBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MINIMUM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MINIMUM>(end);
    fbb_.Required(o, MINIMUM::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<MINIMUM> CreateMINIMUM(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  MINIMUMBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct MINIMUM::Traits {
  using type = MINIMUM;
  static auto constexpr Create = CreateMINIMUM;
};

struct MAXIMUM FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MAXIMUMBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct MAXIMUMBuilder {
  typedef MAXIMUM Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(MAXIMUM::VT_LINK, link);
  }
  explicit MAXIMUMBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MAXIMUM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MAXIMUM>(end);
    fbb_.Required(o, MAXIMUM::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<MAXIMUM> CreateMAXIMUM(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  MAXIMUMBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct MAXIMUM::Traits {
  using type = MAXIMUM;
  static auto constexpr Create = CreateMAXIMUM;
};

struct LOG FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LOGBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct LOGBuilder {
  typedef LOG Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(LOG::VT_LINK, link);
  }
  explicit LOGBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LOG> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LOG>(end);
    fbb_.Required(o, LOG::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<LOG> CreateLOG(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  LOGBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct LOG::Traits {
  using type = LOG;
  static auto constexpr Create = CreateLOG;
};

struct ABS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ABSBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct ABSBuilder {
  typedef ABS Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(ABS::VT_LINK, link);
  }
  explicit ABSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ABS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ABS>(end);
    fbb_.Required(o, ABS::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<ABS> CreateABS(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  ABSBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct ABS::Traits {
  using type = ABS;
  static auto constexpr Create = CreateABS;
};

struct EXP FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EXPBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct EXPBuilder {
  typedef EXP Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(EXP::VT_LINK, link);
  }
  explicit EXPBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EXP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EXP>(end);
    fbb_.Required(o, EXP::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<EXP> CreateEXP(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  EXPBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct EXP::Traits {
  using type = EXP;
  static auto constexpr Create = CreateEXP;
};

struct GATHER FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GATHERBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_AXIS = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
};

struct GATHERBuilder {
  typedef GATHER Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(GATHER::VT_LINK, link);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(GATHER::VT_AXIS, axis, 0);
  }
  explicit GATHERBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GATHER> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GATHER>(end);
    fbb_.Required(o, GATHER::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<GATHER> CreateGATHER(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    int32_t axis = 0) {
  GATHERBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_link(link);
  return builder_.Finish();
}

struct GATHER::Traits {
  using type = GATHER;
  static auto constexpr Create = CreateGATHER;
};

struct RESHAPE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RESHAPEBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_AXES = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const flatbuffers::Vector<int32_t> *axes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyOffset(verifier, VT_AXES) &&
           verifier.VerifyVector(axes()) &&
           verifier.EndTable();
  }
};

struct RESHAPEBuilder {
  typedef RESHAPE Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(RESHAPE::VT_LINK, link);
  }
  void add_axes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axes) {
    fbb_.AddOffset(RESHAPE::VT_AXES, axes);
  }
  explicit RESHAPEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RESHAPE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RESHAPE>(end);
    fbb_.Required(o, RESHAPE::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<RESHAPE> CreateRESHAPE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axes = 0) {
  RESHAPEBuilder builder_(_fbb);
  builder_.add_axes(axes);
  builder_.add_link(link);
  return builder_.Finish();
}

struct RESHAPE::Traits {
  using type = RESHAPE;
  static auto constexpr Create = CreateRESHAPE;
};

inline flatbuffers::Offset<RESHAPE> CreateRESHAPEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const std::vector<int32_t> *axes = nullptr) {
  auto axes__ = axes ? _fbb.CreateVector<int32_t>(*axes) : 0;
  return nn::CreateRESHAPE(
      _fbb,
      link,
      axes__);
}

struct Graph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GraphBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_NODE_TYPE = 6,
    VT_NODE = 8,
    VT_INITIALIZERS_TYPE = 10,
    VT_INITIALIZERS = 12,
    VT_INPUTS = 14,
    VT_QUANT_INFOS = 16,
    VT_OUTPUTS = 18
  };
  const nn::versionInfo *version() const {
    return GetStruct<const nn::versionInfo *>(VT_VERSION);
  }
  const flatbuffers::Vector<nn::Layer> *node_type() const {
    return GetPointer<const flatbuffers::Vector<nn::Layer> *>(VT_NODE_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *node() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_NODE);
  }
  const flatbuffers::Vector<nn::Tensor> *initializers_type() const {
    return GetPointer<const flatbuffers::Vector<nn::Tensor> *>(VT_INITIALIZERS_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *initializers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_INITIALIZERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<nn::Input>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<nn::Input>> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<nn::QuantInfo>> *quant_infos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<nn::QuantInfo>> *>(VT_QUANT_INFOS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_OUTPUTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<nn::versionInfo>(verifier, VT_VERSION, 8) &&
           VerifyOffset(verifier, VT_NODE_TYPE) &&
           verifier.VerifyVector(node_type()) &&
           VerifyOffset(verifier, VT_NODE) &&
           verifier.VerifyVector(node()) &&
           VerifyLayerVector(verifier, node(), node_type()) &&
           VerifyOffset(verifier, VT_INITIALIZERS_TYPE) &&
           verifier.VerifyVector(initializers_type()) &&
           VerifyOffset(verifier, VT_INITIALIZERS) &&
           verifier.VerifyVector(initializers()) &&
           VerifyTensorVector(verifier, initializers(), initializers_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfTables(inputs()) &&
           VerifyOffset(verifier, VT_QUANT_INFOS) &&
           verifier.VerifyVector(quant_infos()) &&
           verifier.VerifyVectorOfTables(quant_infos()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfStrings(outputs()) &&
           verifier.EndTable();
  }
};

struct GraphBuilder {
  typedef Graph Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(const nn::versionInfo *version) {
    fbb_.AddStruct(Graph::VT_VERSION, version);
  }
  void add_node_type(flatbuffers::Offset<flatbuffers::Vector<nn::Layer>> node_type) {
    fbb_.AddOffset(Graph::VT_NODE_TYPE, node_type);
  }
  void add_node(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> node) {
    fbb_.AddOffset(Graph::VT_NODE, node);
  }
  void add_initializers_type(flatbuffers::Offset<flatbuffers::Vector<nn::Tensor>> initializers_type) {
    fbb_.AddOffset(Graph::VT_INITIALIZERS_TYPE, initializers_type);
  }
  void add_initializers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> initializers) {
    fbb_.AddOffset(Graph::VT_INITIALIZERS, initializers);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<nn::Input>>> inputs) {
    fbb_.AddOffset(Graph::VT_INPUTS, inputs);
  }
  void add_quant_infos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<nn::QuantInfo>>> quant_infos) {
    fbb_.AddOffset(Graph::VT_QUANT_INFOS, quant_infos);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> outputs) {
    fbb_.AddOffset(Graph::VT_OUTPUTS, outputs);
  }
  explicit GraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Graph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Graph>(end);
    return o;
  }
};

inline flatbuffers::Offset<Graph> CreateGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    const nn::versionInfo *version = nullptr,
    flatbuffers::Offset<flatbuffers::Vector<nn::Layer>> node_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> node = 0,
    flatbuffers::Offset<flatbuffers::Vector<nn::Tensor>> initializers_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> initializers = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<nn::Input>>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<nn::QuantInfo>>> quant_infos = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> outputs = 0) {
  GraphBuilder builder_(_fbb);
  builder_.add_outputs(outputs);
  builder_.add_quant_infos(quant_infos);
  builder_.add_inputs(inputs);
  builder_.add_initializers(initializers);
  builder_.add_initializers_type(initializers_type);
  builder_.add_node(node);
  builder_.add_node_type(node_type);
  builder_.add_version(version);
  return builder_.Finish();
}

struct Graph::Traits {
  using type = Graph;
  static auto constexpr Create = CreateGraph;
};

inline flatbuffers::Offset<Graph> CreateGraphDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const nn::versionInfo *version = nullptr,
    const std::vector<nn::Layer> *node_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *node = nullptr,
    const std::vector<nn::Tensor> *initializers_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *initializers = nullptr,
    const std::vector<flatbuffers::Offset<nn::Input>> *inputs = nullptr,
    const std::vector<flatbuffers::Offset<nn::QuantInfo>> *quant_infos = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *outputs = nullptr) {
  auto node_type__ = node_type ? _fbb.CreateVector<nn::Layer>(*node_type) : 0;
  auto node__ = node ? _fbb.CreateVector<flatbuffers::Offset<void>>(*node) : 0;
  auto initializers_type__ = initializers_type ? _fbb.CreateVector<nn::Tensor>(*initializers_type) : 0;
  auto initializers__ = initializers ? _fbb.CreateVector<flatbuffers::Offset<void>>(*initializers) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<flatbuffers::Offset<nn::Input>>(*inputs) : 0;
  auto quant_infos__ = quant_infos ? _fbb.CreateVector<flatbuffers::Offset<nn::QuantInfo>>(*quant_infos) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*outputs) : 0;
  return nn::CreateGraph(
      _fbb,
      version,
      node_type__,
      node__,
      initializers_type__,
      initializers__,
      inputs__,
      quant_infos__,
      outputs__);
}

inline bool VerifyTensor(flatbuffers::Verifier &verifier, const void *obj, Tensor type) {
  switch (type) {
    case Tensor::NONE: {
      return true;
    }
    case Tensor::ubyteTensor: {
      auto ptr = reinterpret_cast<const nn::ubyteTensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Tensor::ushortTensor: {
      auto ptr = reinterpret_cast<const nn::ushortTensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Tensor::uintTensor: {
      auto ptr = reinterpret_cast<const nn::uintTensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Tensor::intTensor: {
      auto ptr = reinterpret_cast<const nn::intTensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Tensor::floatTensor: {
      auto ptr = reinterpret_cast<const nn::floatTensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Tensor::doubleTensor: {
      auto ptr = reinterpret_cast<const nn::doubleTensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTensorVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<Tensor> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyTensor(
        verifier,  values->Get(i), types->GetEnum<Tensor>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyLayer(flatbuffers::Verifier &verifier, const void *obj, Layer type) {
  switch (type) {
    case Layer::NONE: {
      return true;
    }
    case Layer::CONV_2D: {
      auto ptr = reinterpret_cast<const nn::CONV_2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::AVERAGE_POOL_2D: {
      auto ptr = reinterpret_cast<const nn::AVERAGE_POOL_2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::MAX_POOL_2D: {
      auto ptr = reinterpret_cast<const nn::MAX_POOL_2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::RELU: {
      auto ptr = reinterpret_cast<const nn::RELU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::SOFTMAX: {
      auto ptr = reinterpret_cast<const nn::SOFTMAX *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::FULLY_CONNECTED: {
      auto ptr = reinterpret_cast<const nn::FULLY_CONNECTED *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::ADD: {
      auto ptr = reinterpret_cast<const nn::ADD *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::CONCATENATION: {
      auto ptr = reinterpret_cast<const nn::CONCATENATION *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::DEPTHWISE_CONV_2D: {
      auto ptr = reinterpret_cast<const nn::DEPTHWISE_CONV_2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::BATCH_TO_SPACE_ND: {
      auto ptr = reinterpret_cast<const nn::BATCH_TO_SPACE_ND *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::SPACE_TO_BATCH_ND: {
      auto ptr = reinterpret_cast<const nn::SPACE_TO_BATCH_ND *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::STRIDED_SLICE: {
      auto ptr = reinterpret_cast<const nn::STRIDED_SLICE *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::MUL: {
      auto ptr = reinterpret_cast<const nn::MUL *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::DEQUANTIZE: {
      auto ptr = reinterpret_cast<const nn::DEQUANTIZE *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::LOCAL_RESPONSE_NORMALIZATION: {
      auto ptr = reinterpret_cast<const nn::LOCAL_RESPONSE_NORMALIZATION *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::TANH: {
      auto ptr = reinterpret_cast<const nn::TANH *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::FLOOR: {
      auto ptr = reinterpret_cast<const nn::FLOOR *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::LOGISTIC: {
      auto ptr = reinterpret_cast<const nn::LOGISTIC *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::PRELU: {
      auto ptr = reinterpret_cast<const nn::PRELU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::POW: {
      auto ptr = reinterpret_cast<const nn::POW *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::NEG: {
      auto ptr = reinterpret_cast<const nn::NEG *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::MINIMUM: {
      auto ptr = reinterpret_cast<const nn::MINIMUM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::MAXIMUM: {
      auto ptr = reinterpret_cast<const nn::MAXIMUM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::LOG: {
      auto ptr = reinterpret_cast<const nn::LOG *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::ABS: {
      auto ptr = reinterpret_cast<const nn::ABS *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::EXP: {
      auto ptr = reinterpret_cast<const nn::EXP *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::SUB: {
      auto ptr = reinterpret_cast<const nn::SUB *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::GATHER: {
      auto ptr = reinterpret_cast<const nn::GATHER *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer::RESHAPE: {
      auto ptr = reinterpret_cast<const nn::RESHAPE *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyLayerVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<Layer> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyLayer(
        verifier,  values->Get(i), types->GetEnum<Layer>(i))) {
      return false;
    }
  }
  return true;
}

inline const nn::Graph *GetGraph(const void *buf) {
  return flatbuffers::GetRoot<nn::Graph>(buf);
}

inline const nn::Graph *GetSizePrefixedGraph(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<nn::Graph>(buf);
}

inline bool VerifyGraphBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<nn::Graph>(nullptr);
}

inline bool VerifySizePrefixedGraphBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<nn::Graph>(nullptr);
}

inline void FinishGraphBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<nn::Graph> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedGraphBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<nn::Graph> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace nn

#endif  // FLATBUFFERS_GENERATED_GNT_NN_H_
