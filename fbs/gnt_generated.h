// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GNT_NN_H_
#define FLATBUFFERS_GENERATED_GNT_NN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 22 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 29,
             "Non-compatible flatbuffers version included");

namespace nn {

struct versionInfo;

struct Tensor;
struct TensorBuilder;

struct QuantInfo;
struct QuantInfoBuilder;

struct Input;
struct InputBuilder;

struct Link;
struct LinkBuilder;

struct Pads;

struct Stride;

struct Dilation;

struct KernelShape;

struct CONV_2D;
struct CONV_2DBuilder;

struct AVERAGE_POOL_2D;
struct AVERAGE_POOL_2DBuilder;

struct MAX_POOL_2D;
struct MAX_POOL_2DBuilder;

struct RELU;
struct RELUBuilder;

struct SOFTMAX;
struct SOFTMAXBuilder;

struct FULLY_CONNECTED;
struct FULLY_CONNECTEDBuilder;

struct ADD;
struct ADDBuilder;

struct CONCATENATION;
struct CONCATENATIONBuilder;

struct DEPTHWISE_CONV_2D;
struct DEPTHWISE_CONV_2DBuilder;

struct BATCH_TO_SPACE_ND;
struct BATCH_TO_SPACE_NDBuilder;

struct SPACE_TO_BATCH_ND;
struct SPACE_TO_BATCH_NDBuilder;

struct STRIDED_SLICE;
struct STRIDED_SLICEBuilder;

struct MUL;
struct MULBuilder;

struct DEQUANTIZE;
struct DEQUANTIZEBuilder;

struct LOCAL_RESPONSE_NORMALIZATION;
struct LOCAL_RESPONSE_NORMALIZATIONBuilder;

struct TANH;
struct TANHBuilder;

struct FLOOR;
struct FLOORBuilder;

struct LOGISTIC;
struct LOGISTICBuilder;

struct PRELU;
struct PRELUBuilder;

struct POW;
struct POWBuilder;

struct NEG;
struct NEGBuilder;

struct MINIMUM;
struct MINIMUMBuilder;

struct MAXIMUM;
struct MAXIMUMBuilder;

struct LOG;
struct LOGBuilder;

struct ABS;
struct ABSBuilder;

struct EXP;
struct EXPBuilder;

struct SUB;
struct SUBBuilder;

struct Graph;
struct GraphBuilder;

enum DataType : int8_t {
  DataType_Float = 0,
  DataType_Int = 1,
  DataType_QuantAsymm = 2,
  DataType_QuantSymm = 3,
  DataType_QuantSymmPerChannel = 4,
  DataType_MIN = DataType_Float,
  DataType_MAX = DataType_QuantSymmPerChannel
};

inline const DataType (&EnumValuesDataType())[5] {
  static const DataType values[] = {
    DataType_Float,
    DataType_Int,
    DataType_QuantAsymm,
    DataType_QuantSymm,
    DataType_QuantSymmPerChannel
  };
  return values;
}

inline const char * const *EnumNamesDataType() {
  static const char * const names[6] = {
    "Float",
    "Int",
    "QuantAsymm",
    "QuantSymm",
    "QuantSymmPerChannel",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataType(DataType e) {
  if (flatbuffers::IsOutRange(e, DataType_Float, DataType_QuantSymmPerChannel)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataType()[index];
}

enum FuseCode : int8_t {
  FuseCode_None = 0,
  FuseCode_Relu = 1,
  FuseCode_Relu1 = 2,
  FuseCode_Relu6 = 3,
  FuseCode_MIN = FuseCode_None,
  FuseCode_MAX = FuseCode_Relu6
};

inline const FuseCode (&EnumValuesFuseCode())[4] {
  static const FuseCode values[] = {
    FuseCode_None,
    FuseCode_Relu,
    FuseCode_Relu1,
    FuseCode_Relu6
  };
  return values;
}

inline const char * const *EnumNamesFuseCode() {
  static const char * const names[5] = {
    "None",
    "Relu",
    "Relu1",
    "Relu6",
    nullptr
  };
  return names;
}

inline const char *EnumNameFuseCode(FuseCode e) {
  if (flatbuffers::IsOutRange(e, FuseCode_None, FuseCode_Relu6)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFuseCode()[index];
}

enum Layer : uint8_t {
  Layer_NONE = 0,
  Layer_CONV_2D = 1,
  Layer_AVERAGE_POOL_2D = 2,
  Layer_MAX_POOL_2D = 3,
  Layer_RELU = 4,
  Layer_SOFTMAX = 5,
  Layer_FULLY_CONNECTED = 6,
  Layer_ADD = 7,
  Layer_CONCATENATION = 8,
  Layer_DEPTHWISE_CONV_2D = 9,
  Layer_BATCH_TO_SPACE_ND = 10,
  Layer_SPACE_TO_BATCH_ND = 11,
  Layer_STRIDED_SLICE = 12,
  Layer_MUL = 13,
  Layer_DEQUANTIZE = 14,
  Layer_LOCAL_RESPONSE_NORMALIZATION = 15,
  Layer_TANH = 16,
  Layer_FLOOR = 17,
  Layer_LOGISTIC = 18,
  Layer_PRELU = 19,
  Layer_POW = 20,
  Layer_NEG = 21,
  Layer_MINIMUM = 22,
  Layer_MAXIMUM = 23,
  Layer_LOG = 24,
  Layer_ABS = 25,
  Layer_EXP = 26,
  Layer_SUB = 27,
  Layer_MIN = Layer_NONE,
  Layer_MAX = Layer_SUB
};

inline const Layer (&EnumValuesLayer())[28] {
  static const Layer values[] = {
    Layer_NONE,
    Layer_CONV_2D,
    Layer_AVERAGE_POOL_2D,
    Layer_MAX_POOL_2D,
    Layer_RELU,
    Layer_SOFTMAX,
    Layer_FULLY_CONNECTED,
    Layer_ADD,
    Layer_CONCATENATION,
    Layer_DEPTHWISE_CONV_2D,
    Layer_BATCH_TO_SPACE_ND,
    Layer_SPACE_TO_BATCH_ND,
    Layer_STRIDED_SLICE,
    Layer_MUL,
    Layer_DEQUANTIZE,
    Layer_LOCAL_RESPONSE_NORMALIZATION,
    Layer_TANH,
    Layer_FLOOR,
    Layer_LOGISTIC,
    Layer_PRELU,
    Layer_POW,
    Layer_NEG,
    Layer_MINIMUM,
    Layer_MAXIMUM,
    Layer_LOG,
    Layer_ABS,
    Layer_EXP,
    Layer_SUB
  };
  return values;
}

inline const char * const *EnumNamesLayer() {
  static const char * const names[29] = {
    "NONE",
    "CONV_2D",
    "AVERAGE_POOL_2D",
    "MAX_POOL_2D",
    "RELU",
    "SOFTMAX",
    "FULLY_CONNECTED",
    "ADD",
    "CONCATENATION",
    "DEPTHWISE_CONV_2D",
    "BATCH_TO_SPACE_ND",
    "SPACE_TO_BATCH_ND",
    "STRIDED_SLICE",
    "MUL",
    "DEQUANTIZE",
    "LOCAL_RESPONSE_NORMALIZATION",
    "TANH",
    "FLOOR",
    "LOGISTIC",
    "PRELU",
    "POW",
    "NEG",
    "MINIMUM",
    "MAXIMUM",
    "LOG",
    "ABS",
    "EXP",
    "SUB",
    nullptr
  };
  return names;
}

inline const char *EnumNameLayer(Layer e) {
  if (flatbuffers::IsOutRange(e, Layer_NONE, Layer_SUB)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLayer()[index];
}

template<typename T> struct LayerTraits {
  static const Layer enum_value = Layer_NONE;
};

template<> struct LayerTraits<nn::CONV_2D> {
  static const Layer enum_value = Layer_CONV_2D;
};

template<> struct LayerTraits<nn::AVERAGE_POOL_2D> {
  static const Layer enum_value = Layer_AVERAGE_POOL_2D;
};

template<> struct LayerTraits<nn::MAX_POOL_2D> {
  static const Layer enum_value = Layer_MAX_POOL_2D;
};

template<> struct LayerTraits<nn::RELU> {
  static const Layer enum_value = Layer_RELU;
};

template<> struct LayerTraits<nn::SOFTMAX> {
  static const Layer enum_value = Layer_SOFTMAX;
};

template<> struct LayerTraits<nn::FULLY_CONNECTED> {
  static const Layer enum_value = Layer_FULLY_CONNECTED;
};

template<> struct LayerTraits<nn::ADD> {
  static const Layer enum_value = Layer_ADD;
};

template<> struct LayerTraits<nn::CONCATENATION> {
  static const Layer enum_value = Layer_CONCATENATION;
};

template<> struct LayerTraits<nn::DEPTHWISE_CONV_2D> {
  static const Layer enum_value = Layer_DEPTHWISE_CONV_2D;
};

template<> struct LayerTraits<nn::BATCH_TO_SPACE_ND> {
  static const Layer enum_value = Layer_BATCH_TO_SPACE_ND;
};

template<> struct LayerTraits<nn::SPACE_TO_BATCH_ND> {
  static const Layer enum_value = Layer_SPACE_TO_BATCH_ND;
};

template<> struct LayerTraits<nn::STRIDED_SLICE> {
  static const Layer enum_value = Layer_STRIDED_SLICE;
};

template<> struct LayerTraits<nn::MUL> {
  static const Layer enum_value = Layer_MUL;
};

template<> struct LayerTraits<nn::DEQUANTIZE> {
  static const Layer enum_value = Layer_DEQUANTIZE;
};

template<> struct LayerTraits<nn::LOCAL_RESPONSE_NORMALIZATION> {
  static const Layer enum_value = Layer_LOCAL_RESPONSE_NORMALIZATION;
};

template<> struct LayerTraits<nn::TANH> {
  static const Layer enum_value = Layer_TANH;
};

template<> struct LayerTraits<nn::FLOOR> {
  static const Layer enum_value = Layer_FLOOR;
};

template<> struct LayerTraits<nn::LOGISTIC> {
  static const Layer enum_value = Layer_LOGISTIC;
};

template<> struct LayerTraits<nn::PRELU> {
  static const Layer enum_value = Layer_PRELU;
};

template<> struct LayerTraits<nn::POW> {
  static const Layer enum_value = Layer_POW;
};

template<> struct LayerTraits<nn::NEG> {
  static const Layer enum_value = Layer_NEG;
};

template<> struct LayerTraits<nn::MINIMUM> {
  static const Layer enum_value = Layer_MINIMUM;
};

template<> struct LayerTraits<nn::MAXIMUM> {
  static const Layer enum_value = Layer_MAXIMUM;
};

template<> struct LayerTraits<nn::LOG> {
  static const Layer enum_value = Layer_LOG;
};

template<> struct LayerTraits<nn::ABS> {
  static const Layer enum_value = Layer_ABS;
};

template<> struct LayerTraits<nn::EXP> {
  static const Layer enum_value = Layer_EXP;
};

template<> struct LayerTraits<nn::SUB> {
  static const Layer enum_value = Layer_SUB;
};

bool VerifyLayer(flatbuffers::Verifier &verifier, const void *obj, Layer type);
bool VerifyLayerVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) versionInfo FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t codeversion_;
  int64_t dataversion_;

 public:
  versionInfo()
      : codeversion_(0),
        dataversion_(0) {
  }
  versionInfo(uint64_t _codeversion, int64_t _dataversion)
      : codeversion_(flatbuffers::EndianScalar(_codeversion)),
        dataversion_(flatbuffers::EndianScalar(_dataversion)) {
  }
  uint64_t codeversion() const {
    return flatbuffers::EndianScalar(codeversion_);
  }
  int64_t dataversion() const {
    return flatbuffers::EndianScalar(dataversion_);
  }
};
FLATBUFFERS_STRUCT_END(versionInfo, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Pads FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t left_;
  int32_t right_;
  int32_t top_;
  int32_t bottom_;

 public:
  Pads()
      : left_(0),
        right_(0),
        top_(0),
        bottom_(0) {
  }
  Pads(int32_t _left, int32_t _right, int32_t _top, int32_t _bottom)
      : left_(flatbuffers::EndianScalar(_left)),
        right_(flatbuffers::EndianScalar(_right)),
        top_(flatbuffers::EndianScalar(_top)),
        bottom_(flatbuffers::EndianScalar(_bottom)) {
  }
  int32_t left() const {
    return flatbuffers::EndianScalar(left_);
  }
  int32_t right() const {
    return flatbuffers::EndianScalar(right_);
  }
  int32_t top() const {
    return flatbuffers::EndianScalar(top_);
  }
  int32_t bottom() const {
    return flatbuffers::EndianScalar(bottom_);
  }
};
FLATBUFFERS_STRUCT_END(Pads, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Stride FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;

 public:
  Stride()
      : x_(0),
        y_(0) {
  }
  Stride(int32_t _x, int32_t _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Stride, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Dilation FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;

 public:
  Dilation()
      : x_(0),
        y_(0) {
  }
  Dilation(int32_t _x, int32_t _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Dilation, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) KernelShape FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t width_;
  int32_t height_;

 public:
  KernelShape()
      : width_(0),
        height_(0) {
  }
  KernelShape(int32_t _width, int32_t _height)
      : width_(flatbuffers::EndianScalar(_width)),
        height_(flatbuffers::EndianScalar(_height)) {
  }
  int32_t width() const {
    return flatbuffers::EndianScalar(width_);
  }
  int32_t height() const {
    return flatbuffers::EndianScalar(height_);
  }
};
FLATBUFFERS_STRUCT_END(KernelShape, 8);

struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_RAW_DATA = 8,
    VT_DIM = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  nn::DataType type() const {
    return static_cast<nn::DataType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<uint8_t> *raw_data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_RAW_DATA);
  }
  const flatbuffers::Vector<uint16_t> *dim() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_DIM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_RAW_DATA) &&
           verifier.VerifyVector(raw_data()) &&
           VerifyOffset(verifier, VT_DIM) &&
           verifier.VerifyVector(dim()) &&
           verifier.EndTable();
  }
};

struct TensorBuilder {
  typedef Tensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Tensor::VT_NAME, name);
  }
  void add_type(nn::DataType type) {
    fbb_.AddElement<int8_t>(Tensor::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_raw_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> raw_data) {
    fbb_.AddOffset(Tensor::VT_RAW_DATA, raw_data);
  }
  void add_dim(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> dim) {
    fbb_.AddOffset(Tensor::VT_DIM, dim);
  }
  explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tensor>(end);
    fbb_.Required(o, Tensor::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Tensor> CreateTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    nn::DataType type = nn::DataType_Float,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> raw_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> dim = 0) {
  TensorBuilder builder_(_fbb);
  builder_.add_dim(dim);
  builder_.add_raw_data(raw_data);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tensor> CreateTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    nn::DataType type = nn::DataType_Float,
    const std::vector<uint8_t> *raw_data = nullptr,
    const std::vector<uint16_t> *dim = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto raw_data__ = raw_data ? _fbb.CreateVector<uint8_t>(*raw_data) : 0;
  auto dim__ = dim ? _fbb.CreateVector<uint16_t>(*dim) : 0;
  return nn::CreateTensor(
      _fbb,
      name__,
      type,
      raw_data__,
      dim__);
}

struct QuantInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuantInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_DIM = 8,
    VT_SCALES = 10,
    VT_ZERO_POINT = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  nn::DataType type() const {
    return static_cast<nn::DataType>(GetField<int8_t>(VT_TYPE, 0));
  }
  uint16_t dim() const {
    return GetField<uint16_t>(VT_DIM, 0);
  }
  const flatbuffers::Vector<float> *scales() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALES);
  }
  int32_t zero_point() const {
    return GetField<int32_t>(VT_ZERO_POINT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint16_t>(verifier, VT_DIM, 2) &&
           VerifyOffset(verifier, VT_SCALES) &&
           verifier.VerifyVector(scales()) &&
           VerifyField<int32_t>(verifier, VT_ZERO_POINT, 4) &&
           verifier.EndTable();
  }
};

struct QuantInfoBuilder {
  typedef QuantInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(QuantInfo::VT_NAME, name);
  }
  void add_type(nn::DataType type) {
    fbb_.AddElement<int8_t>(QuantInfo::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_dim(uint16_t dim) {
    fbb_.AddElement<uint16_t>(QuantInfo::VT_DIM, dim, 0);
  }
  void add_scales(flatbuffers::Offset<flatbuffers::Vector<float>> scales) {
    fbb_.AddOffset(QuantInfo::VT_SCALES, scales);
  }
  void add_zero_point(int32_t zero_point) {
    fbb_.AddElement<int32_t>(QuantInfo::VT_ZERO_POINT, zero_point, 0);
  }
  explicit QuantInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<QuantInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantInfo>(end);
    fbb_.Required(o, QuantInfo::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<QuantInfo> CreateQuantInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    nn::DataType type = nn::DataType_Float,
    uint16_t dim = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scales = 0,
    int32_t zero_point = 0) {
  QuantInfoBuilder builder_(_fbb);
  builder_.add_zero_point(zero_point);
  builder_.add_scales(scales);
  builder_.add_name(name);
  builder_.add_dim(dim);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<QuantInfo> CreateQuantInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    nn::DataType type = nn::DataType_Float,
    uint16_t dim = 0,
    const std::vector<float> *scales = nullptr,
    int32_t zero_point = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto scales__ = scales ? _fbb.CreateVector<float>(*scales) : 0;
  return nn::CreateQuantInfo(
      _fbb,
      name__,
      type,
      dim,
      scales__,
      zero_point);
}

struct Input FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InputBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DIM = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<uint16_t> *dim() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_DIM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DIM) &&
           verifier.VerifyVector(dim()) &&
           verifier.EndTable();
  }
};

struct InputBuilder {
  typedef Input Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Input::VT_NAME, name);
  }
  void add_dim(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> dim) {
    fbb_.AddOffset(Input::VT_DIM, dim);
  }
  explicit InputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Input> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Input>(end);
    return o;
  }
};

inline flatbuffers::Offset<Input> CreateInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> dim = 0) {
  InputBuilder builder_(_fbb);
  builder_.add_dim(dim);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Input> CreateInputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<uint16_t> *dim = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto dim__ = dim ? _fbb.CreateVector<uint16_t>(*dim) : 0;
  return nn::CreateInput(
      _fbb,
      name__,
      dim__);
}

struct Link FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LinkBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_OUTPUT = 6,
    VT_NAME = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *input() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_INPUT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *output() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_OUTPUT);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_INPUT) &&
           verifier.VerifyVector(input()) &&
           verifier.VerifyVectorOfStrings(input()) &&
           VerifyOffsetRequired(verifier, VT_OUTPUT) &&
           verifier.VerifyVector(output()) &&
           verifier.VerifyVectorOfStrings(output()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct LinkBuilder {
  typedef Link Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> input) {
    fbb_.AddOffset(Link::VT_INPUT, input);
  }
  void add_output(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> output) {
    fbb_.AddOffset(Link::VT_OUTPUT, output);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Link::VT_NAME, name);
  }
  explicit LinkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Link> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Link>(end);
    fbb_.Required(o, Link::VT_INPUT);
    fbb_.Required(o, Link::VT_OUTPUT);
    return o;
  }
};

inline flatbuffers::Offset<Link> CreateLink(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> input = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> output = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  LinkBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_output(output);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<Link> CreateLinkDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *input = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *output = nullptr,
    const char *name = nullptr) {
  auto input__ = input ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*input) : 0;
  auto output__ = output ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*output) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return nn::CreateLink(
      _fbb,
      input__,
      output__,
      name__);
}

struct CONV_2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CONV_2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_PADDING = 6,
    VT_STRIDE = 8,
    VT_DILATION = 10,
    VT_FUSE_CODE = 12
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const nn::Pads *padding() const {
    return GetStruct<const nn::Pads *>(VT_PADDING);
  }
  const nn::Stride *stride() const {
    return GetStruct<const nn::Stride *>(VT_STRIDE);
  }
  const nn::Dilation *dilation() const {
    return GetStruct<const nn::Dilation *>(VT_DILATION);
  }
  nn::FuseCode fuse_code() const {
    return static_cast<nn::FuseCode>(GetField<int8_t>(VT_FUSE_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<nn::Pads>(verifier, VT_PADDING, 4) &&
           VerifyField<nn::Stride>(verifier, VT_STRIDE, 4) &&
           VerifyField<nn::Dilation>(verifier, VT_DILATION, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSE_CODE, 1) &&
           verifier.EndTable();
  }
};

struct CONV_2DBuilder {
  typedef CONV_2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(CONV_2D::VT_LINK, link);
  }
  void add_padding(const nn::Pads *padding) {
    fbb_.AddStruct(CONV_2D::VT_PADDING, padding);
  }
  void add_stride(const nn::Stride *stride) {
    fbb_.AddStruct(CONV_2D::VT_STRIDE, stride);
  }
  void add_dilation(const nn::Dilation *dilation) {
    fbb_.AddStruct(CONV_2D::VT_DILATION, dilation);
  }
  void add_fuse_code(nn::FuseCode fuse_code) {
    fbb_.AddElement<int8_t>(CONV_2D::VT_FUSE_CODE, static_cast<int8_t>(fuse_code), 0);
  }
  explicit CONV_2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CONV_2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CONV_2D>(end);
    fbb_.Required(o, CONV_2D::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<CONV_2D> CreateCONV_2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const nn::Pads *padding = nullptr,
    const nn::Stride *stride = nullptr,
    const nn::Dilation *dilation = nullptr,
    nn::FuseCode fuse_code = nn::FuseCode_None) {
  CONV_2DBuilder builder_(_fbb);
  builder_.add_dilation(dilation);
  builder_.add_stride(stride);
  builder_.add_padding(padding);
  builder_.add_link(link);
  builder_.add_fuse_code(fuse_code);
  return builder_.Finish();
}

struct AVERAGE_POOL_2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AVERAGE_POOL_2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_PADDING = 6,
    VT_STRIDE = 8,
    VT_KERNEL_SHAPE = 10,
    VT_FUSE_CODE = 12
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const nn::Pads *padding() const {
    return GetStruct<const nn::Pads *>(VT_PADDING);
  }
  const nn::Stride *stride() const {
    return GetStruct<const nn::Stride *>(VT_STRIDE);
  }
  const nn::KernelShape *kernel_shape() const {
    return GetStruct<const nn::KernelShape *>(VT_KERNEL_SHAPE);
  }
  nn::FuseCode fuse_code() const {
    return static_cast<nn::FuseCode>(GetField<int8_t>(VT_FUSE_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<nn::Pads>(verifier, VT_PADDING, 4) &&
           VerifyField<nn::Stride>(verifier, VT_STRIDE, 4) &&
           VerifyField<nn::KernelShape>(verifier, VT_KERNEL_SHAPE, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSE_CODE, 1) &&
           verifier.EndTable();
  }
};

struct AVERAGE_POOL_2DBuilder {
  typedef AVERAGE_POOL_2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(AVERAGE_POOL_2D::VT_LINK, link);
  }
  void add_padding(const nn::Pads *padding) {
    fbb_.AddStruct(AVERAGE_POOL_2D::VT_PADDING, padding);
  }
  void add_stride(const nn::Stride *stride) {
    fbb_.AddStruct(AVERAGE_POOL_2D::VT_STRIDE, stride);
  }
  void add_kernel_shape(const nn::KernelShape *kernel_shape) {
    fbb_.AddStruct(AVERAGE_POOL_2D::VT_KERNEL_SHAPE, kernel_shape);
  }
  void add_fuse_code(nn::FuseCode fuse_code) {
    fbb_.AddElement<int8_t>(AVERAGE_POOL_2D::VT_FUSE_CODE, static_cast<int8_t>(fuse_code), 0);
  }
  explicit AVERAGE_POOL_2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AVERAGE_POOL_2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AVERAGE_POOL_2D>(end);
    fbb_.Required(o, AVERAGE_POOL_2D::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<AVERAGE_POOL_2D> CreateAVERAGE_POOL_2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const nn::Pads *padding = nullptr,
    const nn::Stride *stride = nullptr,
    const nn::KernelShape *kernel_shape = nullptr,
    nn::FuseCode fuse_code = nn::FuseCode_None) {
  AVERAGE_POOL_2DBuilder builder_(_fbb);
  builder_.add_kernel_shape(kernel_shape);
  builder_.add_stride(stride);
  builder_.add_padding(padding);
  builder_.add_link(link);
  builder_.add_fuse_code(fuse_code);
  return builder_.Finish();
}

struct MAX_POOL_2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MAX_POOL_2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_PADDING = 6,
    VT_STRIDE = 8,
    VT_KERNEL_SHAPE = 10,
    VT_FUSE_CODE = 12
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const nn::Pads *padding() const {
    return GetStruct<const nn::Pads *>(VT_PADDING);
  }
  const nn::Stride *stride() const {
    return GetStruct<const nn::Stride *>(VT_STRIDE);
  }
  const nn::KernelShape *kernel_shape() const {
    return GetStruct<const nn::KernelShape *>(VT_KERNEL_SHAPE);
  }
  nn::FuseCode fuse_code() const {
    return static_cast<nn::FuseCode>(GetField<int8_t>(VT_FUSE_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<nn::Pads>(verifier, VT_PADDING, 4) &&
           VerifyField<nn::Stride>(verifier, VT_STRIDE, 4) &&
           VerifyField<nn::KernelShape>(verifier, VT_KERNEL_SHAPE, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSE_CODE, 1) &&
           verifier.EndTable();
  }
};

struct MAX_POOL_2DBuilder {
  typedef MAX_POOL_2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(MAX_POOL_2D::VT_LINK, link);
  }
  void add_padding(const nn::Pads *padding) {
    fbb_.AddStruct(MAX_POOL_2D::VT_PADDING, padding);
  }
  void add_stride(const nn::Stride *stride) {
    fbb_.AddStruct(MAX_POOL_2D::VT_STRIDE, stride);
  }
  void add_kernel_shape(const nn::KernelShape *kernel_shape) {
    fbb_.AddStruct(MAX_POOL_2D::VT_KERNEL_SHAPE, kernel_shape);
  }
  void add_fuse_code(nn::FuseCode fuse_code) {
    fbb_.AddElement<int8_t>(MAX_POOL_2D::VT_FUSE_CODE, static_cast<int8_t>(fuse_code), 0);
  }
  explicit MAX_POOL_2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MAX_POOL_2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MAX_POOL_2D>(end);
    fbb_.Required(o, MAX_POOL_2D::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<MAX_POOL_2D> CreateMAX_POOL_2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const nn::Pads *padding = nullptr,
    const nn::Stride *stride = nullptr,
    const nn::KernelShape *kernel_shape = nullptr,
    nn::FuseCode fuse_code = nn::FuseCode_None) {
  MAX_POOL_2DBuilder builder_(_fbb);
  builder_.add_kernel_shape(kernel_shape);
  builder_.add_stride(stride);
  builder_.add_padding(padding);
  builder_.add_link(link);
  builder_.add_fuse_code(fuse_code);
  return builder_.Finish();
}

struct RELU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RELUBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct RELUBuilder {
  typedef RELU Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(RELU::VT_LINK, link);
  }
  explicit RELUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RELU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RELU>(end);
    fbb_.Required(o, RELU::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<RELU> CreateRELU(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  RELUBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct SOFTMAX FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SOFTMAXBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_BETA = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<float>(verifier, VT_BETA, 4) &&
           verifier.EndTable();
  }
};

struct SOFTMAXBuilder {
  typedef SOFTMAX Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(SOFTMAX::VT_LINK, link);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(SOFTMAX::VT_BETA, beta, 0.0f);
  }
  explicit SOFTMAXBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SOFTMAX> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SOFTMAX>(end);
    fbb_.Required(o, SOFTMAX::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<SOFTMAX> CreateSOFTMAX(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    float beta = 0.0f) {
  SOFTMAXBuilder builder_(_fbb);
  builder_.add_beta(beta);
  builder_.add_link(link);
  return builder_.Finish();
}

struct FULLY_CONNECTED FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FULLY_CONNECTEDBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_FUSE_CODE = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  nn::FuseCode fuse_code() const {
    return static_cast<nn::FuseCode>(GetField<int8_t>(VT_FUSE_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<int8_t>(verifier, VT_FUSE_CODE, 1) &&
           verifier.EndTable();
  }
};

struct FULLY_CONNECTEDBuilder {
  typedef FULLY_CONNECTED Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(FULLY_CONNECTED::VT_LINK, link);
  }
  void add_fuse_code(nn::FuseCode fuse_code) {
    fbb_.AddElement<int8_t>(FULLY_CONNECTED::VT_FUSE_CODE, static_cast<int8_t>(fuse_code), 0);
  }
  explicit FULLY_CONNECTEDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FULLY_CONNECTED> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FULLY_CONNECTED>(end);
    fbb_.Required(o, FULLY_CONNECTED::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<FULLY_CONNECTED> CreateFULLY_CONNECTED(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    nn::FuseCode fuse_code = nn::FuseCode_None) {
  FULLY_CONNECTEDBuilder builder_(_fbb);
  builder_.add_link(link);
  builder_.add_fuse_code(fuse_code);
  return builder_.Finish();
}

struct ADD FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ADDBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_FUSE_CODE = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  nn::FuseCode fuse_code() const {
    return static_cast<nn::FuseCode>(GetField<int8_t>(VT_FUSE_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<int8_t>(verifier, VT_FUSE_CODE, 1) &&
           verifier.EndTable();
  }
};

struct ADDBuilder {
  typedef ADD Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(ADD::VT_LINK, link);
  }
  void add_fuse_code(nn::FuseCode fuse_code) {
    fbb_.AddElement<int8_t>(ADD::VT_FUSE_CODE, static_cast<int8_t>(fuse_code), 0);
  }
  explicit ADDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ADD> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ADD>(end);
    fbb_.Required(o, ADD::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<ADD> CreateADD(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    nn::FuseCode fuse_code = nn::FuseCode_None) {
  ADDBuilder builder_(_fbb);
  builder_.add_link(link);
  builder_.add_fuse_code(fuse_code);
  return builder_.Finish();
}

struct CONCATENATION FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CONCATENATIONBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_AXIS = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
};

struct CONCATENATIONBuilder {
  typedef CONCATENATION Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(CONCATENATION::VT_LINK, link);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(CONCATENATION::VT_AXIS, axis, 0);
  }
  explicit CONCATENATIONBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CONCATENATION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CONCATENATION>(end);
    fbb_.Required(o, CONCATENATION::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<CONCATENATION> CreateCONCATENATION(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    int32_t axis = 0) {
  CONCATENATIONBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_link(link);
  return builder_.Finish();
}

struct DEPTHWISE_CONV_2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DEPTHWISE_CONV_2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_PADDING = 6,
    VT_STRIDE = 8,
    VT_DEPTH_MULTIPLIER = 10,
    VT_FUSE_CODE = 12
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const nn::Pads *padding() const {
    return GetStruct<const nn::Pads *>(VT_PADDING);
  }
  const nn::Stride *stride() const {
    return GetStruct<const nn::Stride *>(VT_STRIDE);
  }
  int32_t depth_multiplier() const {
    return GetField<int32_t>(VT_DEPTH_MULTIPLIER, 0);
  }
  nn::FuseCode fuse_code() const {
    return static_cast<nn::FuseCode>(GetField<int8_t>(VT_FUSE_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<nn::Pads>(verifier, VT_PADDING, 4) &&
           VerifyField<nn::Stride>(verifier, VT_STRIDE, 4) &&
           VerifyField<int32_t>(verifier, VT_DEPTH_MULTIPLIER, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSE_CODE, 1) &&
           verifier.EndTable();
  }
};

struct DEPTHWISE_CONV_2DBuilder {
  typedef DEPTHWISE_CONV_2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(DEPTHWISE_CONV_2D::VT_LINK, link);
  }
  void add_padding(const nn::Pads *padding) {
    fbb_.AddStruct(DEPTHWISE_CONV_2D::VT_PADDING, padding);
  }
  void add_stride(const nn::Stride *stride) {
    fbb_.AddStruct(DEPTHWISE_CONV_2D::VT_STRIDE, stride);
  }
  void add_depth_multiplier(int32_t depth_multiplier) {
    fbb_.AddElement<int32_t>(DEPTHWISE_CONV_2D::VT_DEPTH_MULTIPLIER, depth_multiplier, 0);
  }
  void add_fuse_code(nn::FuseCode fuse_code) {
    fbb_.AddElement<int8_t>(DEPTHWISE_CONV_2D::VT_FUSE_CODE, static_cast<int8_t>(fuse_code), 0);
  }
  explicit DEPTHWISE_CONV_2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DEPTHWISE_CONV_2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DEPTHWISE_CONV_2D>(end);
    fbb_.Required(o, DEPTHWISE_CONV_2D::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<DEPTHWISE_CONV_2D> CreateDEPTHWISE_CONV_2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const nn::Pads *padding = nullptr,
    const nn::Stride *stride = nullptr,
    int32_t depth_multiplier = 0,
    nn::FuseCode fuse_code = nn::FuseCode_None) {
  DEPTHWISE_CONV_2DBuilder builder_(_fbb);
  builder_.add_depth_multiplier(depth_multiplier);
  builder_.add_stride(stride);
  builder_.add_padding(padding);
  builder_.add_link(link);
  builder_.add_fuse_code(fuse_code);
  return builder_.Finish();
}

struct BATCH_TO_SPACE_ND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BATCH_TO_SPACE_NDBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_BLOCK_SIZES = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const flatbuffers::Vector<int32_t> *block_sizes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCK_SIZES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyOffset(verifier, VT_BLOCK_SIZES) &&
           verifier.VerifyVector(block_sizes()) &&
           verifier.EndTable();
  }
};

struct BATCH_TO_SPACE_NDBuilder {
  typedef BATCH_TO_SPACE_ND Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(BATCH_TO_SPACE_ND::VT_LINK, link);
  }
  void add_block_sizes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_sizes) {
    fbb_.AddOffset(BATCH_TO_SPACE_ND::VT_BLOCK_SIZES, block_sizes);
  }
  explicit BATCH_TO_SPACE_NDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BATCH_TO_SPACE_ND> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BATCH_TO_SPACE_ND>(end);
    fbb_.Required(o, BATCH_TO_SPACE_ND::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<BATCH_TO_SPACE_ND> CreateBATCH_TO_SPACE_ND(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_sizes = 0) {
  BATCH_TO_SPACE_NDBuilder builder_(_fbb);
  builder_.add_block_sizes(block_sizes);
  builder_.add_link(link);
  return builder_.Finish();
}

inline flatbuffers::Offset<BATCH_TO_SPACE_ND> CreateBATCH_TO_SPACE_NDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const std::vector<int32_t> *block_sizes = nullptr) {
  auto block_sizes__ = block_sizes ? _fbb.CreateVector<int32_t>(*block_sizes) : 0;
  return nn::CreateBATCH_TO_SPACE_ND(
      _fbb,
      link,
      block_sizes__);
}

struct SPACE_TO_BATCH_ND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SPACE_TO_BATCH_NDBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_BLOCK_SIZES = 6,
    VT_PADDING = 8
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const flatbuffers::Vector<int32_t> *block_sizes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCK_SIZES);
  }
  const nn::Pads *padding() const {
    return GetStruct<const nn::Pads *>(VT_PADDING);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyOffset(verifier, VT_BLOCK_SIZES) &&
           verifier.VerifyVector(block_sizes()) &&
           VerifyField<nn::Pads>(verifier, VT_PADDING, 4) &&
           verifier.EndTable();
  }
};

struct SPACE_TO_BATCH_NDBuilder {
  typedef SPACE_TO_BATCH_ND Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(SPACE_TO_BATCH_ND::VT_LINK, link);
  }
  void add_block_sizes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_sizes) {
    fbb_.AddOffset(SPACE_TO_BATCH_ND::VT_BLOCK_SIZES, block_sizes);
  }
  void add_padding(const nn::Pads *padding) {
    fbb_.AddStruct(SPACE_TO_BATCH_ND::VT_PADDING, padding);
  }
  explicit SPACE_TO_BATCH_NDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SPACE_TO_BATCH_ND> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SPACE_TO_BATCH_ND>(end);
    fbb_.Required(o, SPACE_TO_BATCH_ND::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<SPACE_TO_BATCH_ND> CreateSPACE_TO_BATCH_ND(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_sizes = 0,
    const nn::Pads *padding = nullptr) {
  SPACE_TO_BATCH_NDBuilder builder_(_fbb);
  builder_.add_padding(padding);
  builder_.add_block_sizes(block_sizes);
  builder_.add_link(link);
  return builder_.Finish();
}

inline flatbuffers::Offset<SPACE_TO_BATCH_ND> CreateSPACE_TO_BATCH_NDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const std::vector<int32_t> *block_sizes = nullptr,
    const nn::Pads *padding = nullptr) {
  auto block_sizes__ = block_sizes ? _fbb.CreateVector<int32_t>(*block_sizes) : 0;
  return nn::CreateSPACE_TO_BATCH_ND(
      _fbb,
      link,
      block_sizes__,
      padding);
}

struct STRIDED_SLICE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef STRIDED_SLICEBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_STARTS = 6,
    VT_ENDS = 8,
    VT_STRIDES = 10,
    VT_BEGIN_MASK = 12,
    VT_END_MASK = 14,
    VT_SHRINK_AXIS_MASK = 16
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const flatbuffers::Vector<int32_t> *starts() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STARTS);
  }
  const flatbuffers::Vector<int32_t> *ends() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ENDS);
  }
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  int32_t begin_mask() const {
    return GetField<int32_t>(VT_BEGIN_MASK, 0);
  }
  int32_t end_mask() const {
    return GetField<int32_t>(VT_END_MASK, 0);
  }
  int32_t shrink_axis_mask() const {
    return GetField<int32_t>(VT_SHRINK_AXIS_MASK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyOffset(verifier, VT_STARTS) &&
           verifier.VerifyVector(starts()) &&
           VerifyOffset(verifier, VT_ENDS) &&
           verifier.VerifyVector(ends()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyField<int32_t>(verifier, VT_BEGIN_MASK, 4) &&
           VerifyField<int32_t>(verifier, VT_END_MASK, 4) &&
           VerifyField<int32_t>(verifier, VT_SHRINK_AXIS_MASK, 4) &&
           verifier.EndTable();
  }
};

struct STRIDED_SLICEBuilder {
  typedef STRIDED_SLICE Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(STRIDED_SLICE::VT_LINK, link);
  }
  void add_starts(flatbuffers::Offset<flatbuffers::Vector<int32_t>> starts) {
    fbb_.AddOffset(STRIDED_SLICE::VT_STARTS, starts);
  }
  void add_ends(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ends) {
    fbb_.AddOffset(STRIDED_SLICE::VT_ENDS, ends);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(STRIDED_SLICE::VT_STRIDES, strides);
  }
  void add_begin_mask(int32_t begin_mask) {
    fbb_.AddElement<int32_t>(STRIDED_SLICE::VT_BEGIN_MASK, begin_mask, 0);
  }
  void add_end_mask(int32_t end_mask) {
    fbb_.AddElement<int32_t>(STRIDED_SLICE::VT_END_MASK, end_mask, 0);
  }
  void add_shrink_axis_mask(int32_t shrink_axis_mask) {
    fbb_.AddElement<int32_t>(STRIDED_SLICE::VT_SHRINK_AXIS_MASK, shrink_axis_mask, 0);
  }
  explicit STRIDED_SLICEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<STRIDED_SLICE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<STRIDED_SLICE>(end);
    fbb_.Required(o, STRIDED_SLICE::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<STRIDED_SLICE> CreateSTRIDED_SLICE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> starts = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ends = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0,
    int32_t begin_mask = 0,
    int32_t end_mask = 0,
    int32_t shrink_axis_mask = 0) {
  STRIDED_SLICEBuilder builder_(_fbb);
  builder_.add_shrink_axis_mask(shrink_axis_mask);
  builder_.add_end_mask(end_mask);
  builder_.add_begin_mask(begin_mask);
  builder_.add_strides(strides);
  builder_.add_ends(ends);
  builder_.add_starts(starts);
  builder_.add_link(link);
  return builder_.Finish();
}

inline flatbuffers::Offset<STRIDED_SLICE> CreateSTRIDED_SLICEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const std::vector<int32_t> *starts = nullptr,
    const std::vector<int32_t> *ends = nullptr,
    const std::vector<int32_t> *strides = nullptr,
    int32_t begin_mask = 0,
    int32_t end_mask = 0,
    int32_t shrink_axis_mask = 0) {
  auto starts__ = starts ? _fbb.CreateVector<int32_t>(*starts) : 0;
  auto ends__ = ends ? _fbb.CreateVector<int32_t>(*ends) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  return nn::CreateSTRIDED_SLICE(
      _fbb,
      link,
      starts__,
      ends__,
      strides__,
      begin_mask,
      end_mask,
      shrink_axis_mask);
}

struct MUL FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MULBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_FUSE_CODE = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  nn::FuseCode fuse_code() const {
    return static_cast<nn::FuseCode>(GetField<int8_t>(VT_FUSE_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<int8_t>(verifier, VT_FUSE_CODE, 1) &&
           verifier.EndTable();
  }
};

struct MULBuilder {
  typedef MUL Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(MUL::VT_LINK, link);
  }
  void add_fuse_code(nn::FuseCode fuse_code) {
    fbb_.AddElement<int8_t>(MUL::VT_FUSE_CODE, static_cast<int8_t>(fuse_code), 0);
  }
  explicit MULBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MUL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MUL>(end);
    fbb_.Required(o, MUL::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<MUL> CreateMUL(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    nn::FuseCode fuse_code = nn::FuseCode_None) {
  MULBuilder builder_(_fbb);
  builder_.add_link(link);
  builder_.add_fuse_code(fuse_code);
  return builder_.Finish();
}

struct DEQUANTIZE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DEQUANTIZEBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct DEQUANTIZEBuilder {
  typedef DEQUANTIZE Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(DEQUANTIZE::VT_LINK, link);
  }
  explicit DEQUANTIZEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DEQUANTIZE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DEQUANTIZE>(end);
    fbb_.Required(o, DEQUANTIZE::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<DEQUANTIZE> CreateDEQUANTIZE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  DEQUANTIZEBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct LOCAL_RESPONSE_NORMALIZATION FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LOCAL_RESPONSE_NORMALIZATIONBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_RADIUS = 6,
    VT_BIAS = 8,
    VT_ALPHA = 10,
    VT_BETA = 12
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  int32_t radius() const {
    return GetField<int32_t>(VT_RADIUS, 0);
  }
  float bias() const {
    return GetField<float>(VT_BIAS, 0.0f);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<int32_t>(verifier, VT_RADIUS, 4) &&
           VerifyField<float>(verifier, VT_BIAS, 4) &&
           VerifyField<float>(verifier, VT_ALPHA, 4) &&
           VerifyField<float>(verifier, VT_BETA, 4) &&
           verifier.EndTable();
  }
};

struct LOCAL_RESPONSE_NORMALIZATIONBuilder {
  typedef LOCAL_RESPONSE_NORMALIZATION Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(LOCAL_RESPONSE_NORMALIZATION::VT_LINK, link);
  }
  void add_radius(int32_t radius) {
    fbb_.AddElement<int32_t>(LOCAL_RESPONSE_NORMALIZATION::VT_RADIUS, radius, 0);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(LOCAL_RESPONSE_NORMALIZATION::VT_BIAS, bias, 0.0f);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LOCAL_RESPONSE_NORMALIZATION::VT_ALPHA, alpha, 0.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(LOCAL_RESPONSE_NORMALIZATION::VT_BETA, beta, 0.0f);
  }
  explicit LOCAL_RESPONSE_NORMALIZATIONBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LOCAL_RESPONSE_NORMALIZATION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LOCAL_RESPONSE_NORMALIZATION>(end);
    fbb_.Required(o, LOCAL_RESPONSE_NORMALIZATION::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<LOCAL_RESPONSE_NORMALIZATION> CreateLOCAL_RESPONSE_NORMALIZATION(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    int32_t radius = 0,
    float bias = 0.0f,
    float alpha = 0.0f,
    float beta = 0.0f) {
  LOCAL_RESPONSE_NORMALIZATIONBuilder builder_(_fbb);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_bias(bias);
  builder_.add_radius(radius);
  builder_.add_link(link);
  return builder_.Finish();
}

struct TANH FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TANHBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct TANHBuilder {
  typedef TANH Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(TANH::VT_LINK, link);
  }
  explicit TANHBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TANH> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TANH>(end);
    fbb_.Required(o, TANH::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<TANH> CreateTANH(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  TANHBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct FLOOR FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FLOORBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct FLOORBuilder {
  typedef FLOOR Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(FLOOR::VT_LINK, link);
  }
  explicit FLOORBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FLOOR> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FLOOR>(end);
    fbb_.Required(o, FLOOR::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<FLOOR> CreateFLOOR(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  FLOORBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct LOGISTIC FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LOGISTICBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct LOGISTICBuilder {
  typedef LOGISTIC Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(LOGISTIC::VT_LINK, link);
  }
  explicit LOGISTICBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LOGISTIC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LOGISTIC>(end);
    fbb_.Required(o, LOGISTIC::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<LOGISTIC> CreateLOGISTIC(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  LOGISTICBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct PRELU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PRELUBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_ALPHA = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const flatbuffers::String *alpha() const {
    return GetPointer<const flatbuffers::String *>(VT_ALPHA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyOffset(verifier, VT_ALPHA) &&
           verifier.VerifyString(alpha()) &&
           verifier.EndTable();
  }
};

struct PRELUBuilder {
  typedef PRELU Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(PRELU::VT_LINK, link);
  }
  void add_alpha(flatbuffers::Offset<flatbuffers::String> alpha) {
    fbb_.AddOffset(PRELU::VT_ALPHA, alpha);
  }
  explicit PRELUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PRELU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PRELU>(end);
    fbb_.Required(o, PRELU::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<PRELU> CreatePRELU(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    flatbuffers::Offset<flatbuffers::String> alpha = 0) {
  PRELUBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  builder_.add_link(link);
  return builder_.Finish();
}

inline flatbuffers::Offset<PRELU> CreatePRELUDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const char *alpha = nullptr) {
  auto alpha__ = alpha ? _fbb.CreateString(alpha) : 0;
  return nn::CreatePRELU(
      _fbb,
      link,
      alpha__);
}

struct POW FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef POWBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_EXP = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  const flatbuffers::String *exp() const {
    return GetPointer<const flatbuffers::String *>(VT_EXP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyOffset(verifier, VT_EXP) &&
           verifier.VerifyString(exp()) &&
           verifier.EndTable();
  }
};

struct POWBuilder {
  typedef POW Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(POW::VT_LINK, link);
  }
  void add_exp(flatbuffers::Offset<flatbuffers::String> exp) {
    fbb_.AddOffset(POW::VT_EXP, exp);
  }
  explicit POWBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<POW> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<POW>(end);
    fbb_.Required(o, POW::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<POW> CreatePOW(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    flatbuffers::Offset<flatbuffers::String> exp = 0) {
  POWBuilder builder_(_fbb);
  builder_.add_exp(exp);
  builder_.add_link(link);
  return builder_.Finish();
}

inline flatbuffers::Offset<POW> CreatePOWDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    const char *exp = nullptr) {
  auto exp__ = exp ? _fbb.CreateString(exp) : 0;
  return nn::CreatePOW(
      _fbb,
      link,
      exp__);
}

struct NEG FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NEGBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct NEGBuilder {
  typedef NEG Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(NEG::VT_LINK, link);
  }
  explicit NEGBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NEG> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NEG>(end);
    fbb_.Required(o, NEG::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<NEG> CreateNEG(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  NEGBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct MINIMUM FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MINIMUMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct MINIMUMBuilder {
  typedef MINIMUM Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(MINIMUM::VT_LINK, link);
  }
  explicit MINIMUMBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MINIMUM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MINIMUM>(end);
    fbb_.Required(o, MINIMUM::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<MINIMUM> CreateMINIMUM(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  MINIMUMBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct MAXIMUM FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MAXIMUMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct MAXIMUMBuilder {
  typedef MAXIMUM Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(MAXIMUM::VT_LINK, link);
  }
  explicit MAXIMUMBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MAXIMUM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MAXIMUM>(end);
    fbb_.Required(o, MAXIMUM::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<MAXIMUM> CreateMAXIMUM(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  MAXIMUMBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct LOG FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LOGBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct LOGBuilder {
  typedef LOG Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(LOG::VT_LINK, link);
  }
  explicit LOGBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LOG> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LOG>(end);
    fbb_.Required(o, LOG::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<LOG> CreateLOG(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  LOGBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct ABS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ABSBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct ABSBuilder {
  typedef ABS Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(ABS::VT_LINK, link);
  }
  explicit ABSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ABS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ABS>(end);
    fbb_.Required(o, ABS::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<ABS> CreateABS(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  ABSBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct EXP FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EXPBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           verifier.EndTable();
  }
};

struct EXPBuilder {
  typedef EXP Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(EXP::VT_LINK, link);
  }
  explicit EXPBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EXP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EXP>(end);
    fbb_.Required(o, EXP::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<EXP> CreateEXP(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0) {
  EXPBuilder builder_(_fbb);
  builder_.add_link(link);
  return builder_.Finish();
}

struct SUB FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SUBBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINK = 4,
    VT_FUSE_CODE = 6
  };
  const nn::Link *link() const {
    return GetPointer<const nn::Link *>(VT_LINK);
  }
  nn::FuseCode fuse_code() const {
    return static_cast<nn::FuseCode>(GetField<int8_t>(VT_FUSE_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINK) &&
           verifier.VerifyTable(link()) &&
           VerifyField<int8_t>(verifier, VT_FUSE_CODE, 1) &&
           verifier.EndTable();
  }
};

struct SUBBuilder {
  typedef SUB Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_link(flatbuffers::Offset<nn::Link> link) {
    fbb_.AddOffset(SUB::VT_LINK, link);
  }
  void add_fuse_code(nn::FuseCode fuse_code) {
    fbb_.AddElement<int8_t>(SUB::VT_FUSE_CODE, static_cast<int8_t>(fuse_code), 0);
  }
  explicit SUBBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SUB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SUB>(end);
    fbb_.Required(o, SUB::VT_LINK);
    return o;
  }
};

inline flatbuffers::Offset<SUB> CreateSUB(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<nn::Link> link = 0,
    nn::FuseCode fuse_code = nn::FuseCode_None) {
  SUBBuilder builder_(_fbb);
  builder_.add_link(link);
  builder_.add_fuse_code(fuse_code);
  return builder_.Finish();
}

struct Graph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GraphBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_NODE_TYPE = 6,
    VT_NODE = 8,
    VT_INITIALIZERS = 10,
    VT_INPUTS = 12,
    VT_QUANT_INFOS = 14,
    VT_OUTPUTS = 16
  };
  const nn::versionInfo *version() const {
    return GetStruct<const nn::versionInfo *>(VT_VERSION);
  }
  const flatbuffers::Vector<uint8_t> *node_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_NODE_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *node() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_NODE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<nn::Tensor>> *initializers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<nn::Tensor>> *>(VT_INITIALIZERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<nn::Input>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<nn::Input>> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<nn::QuantInfo>> *quant_infos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<nn::QuantInfo>> *>(VT_QUANT_INFOS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_OUTPUTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<nn::versionInfo>(verifier, VT_VERSION, 8) &&
           VerifyOffset(verifier, VT_NODE_TYPE) &&
           verifier.VerifyVector(node_type()) &&
           VerifyOffset(verifier, VT_NODE) &&
           verifier.VerifyVector(node()) &&
           VerifyLayerVector(verifier, node(), node_type()) &&
           VerifyOffset(verifier, VT_INITIALIZERS) &&
           verifier.VerifyVector(initializers()) &&
           verifier.VerifyVectorOfTables(initializers()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfTables(inputs()) &&
           VerifyOffset(verifier, VT_QUANT_INFOS) &&
           verifier.VerifyVector(quant_infos()) &&
           verifier.VerifyVectorOfTables(quant_infos()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfStrings(outputs()) &&
           verifier.EndTable();
  }
};

struct GraphBuilder {
  typedef Graph Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(const nn::versionInfo *version) {
    fbb_.AddStruct(Graph::VT_VERSION, version);
  }
  void add_node_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> node_type) {
    fbb_.AddOffset(Graph::VT_NODE_TYPE, node_type);
  }
  void add_node(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> node) {
    fbb_.AddOffset(Graph::VT_NODE, node);
  }
  void add_initializers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<nn::Tensor>>> initializers) {
    fbb_.AddOffset(Graph::VT_INITIALIZERS, initializers);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<nn::Input>>> inputs) {
    fbb_.AddOffset(Graph::VT_INPUTS, inputs);
  }
  void add_quant_infos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<nn::QuantInfo>>> quant_infos) {
    fbb_.AddOffset(Graph::VT_QUANT_INFOS, quant_infos);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> outputs) {
    fbb_.AddOffset(Graph::VT_OUTPUTS, outputs);
  }
  explicit GraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Graph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Graph>(end);
    return o;
  }
};

inline flatbuffers::Offset<Graph> CreateGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    const nn::versionInfo *version = nullptr,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> node_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> node = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<nn::Tensor>>> initializers = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<nn::Input>>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<nn::QuantInfo>>> quant_infos = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> outputs = 0) {
  GraphBuilder builder_(_fbb);
  builder_.add_outputs(outputs);
  builder_.add_quant_infos(quant_infos);
  builder_.add_inputs(inputs);
  builder_.add_initializers(initializers);
  builder_.add_node(node);
  builder_.add_node_type(node_type);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<Graph> CreateGraphDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const nn::versionInfo *version = nullptr,
    const std::vector<uint8_t> *node_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *node = nullptr,
    const std::vector<flatbuffers::Offset<nn::Tensor>> *initializers = nullptr,
    const std::vector<flatbuffers::Offset<nn::Input>> *inputs = nullptr,
    const std::vector<flatbuffers::Offset<nn::QuantInfo>> *quant_infos = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *outputs = nullptr) {
  auto node_type__ = node_type ? _fbb.CreateVector<uint8_t>(*node_type) : 0;
  auto node__ = node ? _fbb.CreateVector<flatbuffers::Offset<void>>(*node) : 0;
  auto initializers__ = initializers ? _fbb.CreateVector<flatbuffers::Offset<nn::Tensor>>(*initializers) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<flatbuffers::Offset<nn::Input>>(*inputs) : 0;
  auto quant_infos__ = quant_infos ? _fbb.CreateVector<flatbuffers::Offset<nn::QuantInfo>>(*quant_infos) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*outputs) : 0;
  return nn::CreateGraph(
      _fbb,
      version,
      node_type__,
      node__,
      initializers__,
      inputs__,
      quant_infos__,
      outputs__);
}

inline bool VerifyLayer(flatbuffers::Verifier &verifier, const void *obj, Layer type) {
  switch (type) {
    case Layer_NONE: {
      return true;
    }
    case Layer_CONV_2D: {
      auto ptr = reinterpret_cast<const nn::CONV_2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer_AVERAGE_POOL_2D: {
      auto ptr = reinterpret_cast<const nn::AVERAGE_POOL_2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer_MAX_POOL_2D: {
      auto ptr = reinterpret_cast<const nn::MAX_POOL_2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer_RELU: {
      auto ptr = reinterpret_cast<const nn::RELU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer_SOFTMAX: {
      auto ptr = reinterpret_cast<const nn::SOFTMAX *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer_FULLY_CONNECTED: {
      auto ptr = reinterpret_cast<const nn::FULLY_CONNECTED *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer_ADD: {
      auto ptr = reinterpret_cast<const nn::ADD *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer_CONCATENATION: {
      auto ptr = reinterpret_cast<const nn::CONCATENATION *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer_DEPTHWISE_CONV_2D: {
      auto ptr = reinterpret_cast<const nn::DEPTHWISE_CONV_2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer_BATCH_TO_SPACE_ND: {
      auto ptr = reinterpret_cast<const nn::BATCH_TO_SPACE_ND *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer_SPACE_TO_BATCH_ND: {
      auto ptr = reinterpret_cast<const nn::SPACE_TO_BATCH_ND *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer_STRIDED_SLICE: {
      auto ptr = reinterpret_cast<const nn::STRIDED_SLICE *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer_MUL: {
      auto ptr = reinterpret_cast<const nn::MUL *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer_DEQUANTIZE: {
      auto ptr = reinterpret_cast<const nn::DEQUANTIZE *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer_LOCAL_RESPONSE_NORMALIZATION: {
      auto ptr = reinterpret_cast<const nn::LOCAL_RESPONSE_NORMALIZATION *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer_TANH: {
      auto ptr = reinterpret_cast<const nn::TANH *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer_FLOOR: {
      auto ptr = reinterpret_cast<const nn::FLOOR *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer_LOGISTIC: {
      auto ptr = reinterpret_cast<const nn::LOGISTIC *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer_PRELU: {
      auto ptr = reinterpret_cast<const nn::PRELU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer_POW: {
      auto ptr = reinterpret_cast<const nn::POW *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer_NEG: {
      auto ptr = reinterpret_cast<const nn::NEG *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer_MINIMUM: {
      auto ptr = reinterpret_cast<const nn::MINIMUM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer_MAXIMUM: {
      auto ptr = reinterpret_cast<const nn::MAXIMUM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer_LOG: {
      auto ptr = reinterpret_cast<const nn::LOG *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer_ABS: {
      auto ptr = reinterpret_cast<const nn::ABS *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer_EXP: {
      auto ptr = reinterpret_cast<const nn::EXP *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Layer_SUB: {
      auto ptr = reinterpret_cast<const nn::SUB *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyLayerVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyLayer(
        verifier,  values->Get(i), types->GetEnum<Layer>(i))) {
      return false;
    }
  }
  return true;
}

inline const nn::Graph *GetGraph(const void *buf) {
  return flatbuffers::GetRoot<nn::Graph>(buf);
}

inline const nn::Graph *GetSizePrefixedGraph(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<nn::Graph>(buf);
}

inline bool VerifyGraphBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<nn::Graph>(nullptr);
}

inline bool VerifySizePrefixedGraphBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<nn::Graph>(nullptr);
}

inline void FinishGraphBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<nn::Graph> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedGraphBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<nn::Graph> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace nn

#endif  // FLATBUFFERS_GENERATED_GNT_NN_H_
